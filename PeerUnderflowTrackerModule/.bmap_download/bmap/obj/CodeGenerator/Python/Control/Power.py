#    obj/CodeGenerator/Python/Control/Power.py
#    Created 27/07/2023 at 10:10:01 from:
#        Messages = messages/Control/Power.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Control_Power_Get :
    ID = 28737
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 7), ("Function", 4), ("Operator", 1)])
    ReverseIDs = OrderedDict([(7, "FunctionBlock"), (4, "Function"), (1, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Control_Power_Get.MSG_OFFSET + Control_Power_Get.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Control_Power_Get.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Control_Power_Get.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Control_Power_Get.MSG_OFFSET + Control_Power_Get.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Control_Power_Get.ID)
            self.hdr.SetDataLength(Control_Power_Get.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Control.Power.Get"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("Control.Power.Get", Control_Power_Get.ID, Control_Power_Get)
#    obj/CodeGenerator/Python/Control/Power.py
#    Created 27/07/2023 at 10:10:01 from:
#        Messages = messages/Control/Power.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Control_Power_Status :
    ID = 28739
    SIZE = 1
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    PowerStatus = OrderedDict([("BMAP_CTRL_PWROFF", 0), ("BMAP_CTRL_PWRON", 1), ("BMAP_CTRL_PWROFF_ON_USB_DISCON", 2)])
    ReversePowerStatus = OrderedDict([(0, "BMAP_CTRL_PWROFF"), (1, "BMAP_CTRL_PWRON"), (2, "BMAP_CTRL_PWROFF_ON_USB_DISCON")])
    IDs = OrderedDict([("FunctionBlock", 7), ("Function", 4), ("Operator", 3)])
    ReverseIDs = OrderedDict([(7, "FunctionBlock"), (4, "Function"), (3, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Control_Power_Status.MSG_OFFSET + Control_Power_Status.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Control_Power_Status.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Control_Power_Status.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Control_Power_Status.MSG_OFFSET + Control_Power_Status.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Control_Power_Status.ID)
            self.hdr.SetDataLength(Control_Power_Status.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Control.Power.Status"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetProductPowerStatus(self, enumAsInt=0):
        """"""
        value = struct.unpack_from('B', self.rawBuffer(), Control_Power_Status.MSG_OFFSET + 0)[0]
        if not enumAsInt:
            value = Control_Power_Status.ReversePowerStatus.get(value, value)
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetProductPowerStatus(self, value):
        """"""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Control_Power_Status.PowerStatus.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Control_Power_Status.MSG_OFFSET + 0, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="ProductPowerStatus",type="enumeration",units="",minVal="0",maxVal="255",description="",get=GetProductPowerStatus,set=SetProductPowerStatus,count=1, bitfieldInfo = [], enum = [PowerStatus, ReversePowerStatus])\
    ]

Messaging.Register("Control.Power.Status", Control_Power_Status.ID, Control_Power_Status)
#    obj/CodeGenerator/Python/Control/Power.py
#    Created 27/07/2023 at 10:10:01 from:
#        Messages = messages/Control/Power.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Control_Power_Start :
    ID = 28741
    SIZE = 3
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    PowerStatus = OrderedDict([("BMAP_CTRL_PWROFF", 0), ("BMAP_CTRL_PWRON", 1), ("BMAP_CTRL_PWROFF_ON_USB_DISCON", 2)])
    ReversePowerStatus = OrderedDict([(0, "BMAP_CTRL_PWROFF"), (1, "BMAP_CTRL_PWRON"), (2, "BMAP_CTRL_PWROFF_ON_USB_DISCON")])
    IDs = OrderedDict([("FunctionBlock", 7), ("Function", 4), ("Operator", 5)])
    ReverseIDs = OrderedDict([(7, "FunctionBlock"), (4, "Function"), (5, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Control_Power_Start.MSG_OFFSET + Control_Power_Start.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Control_Power_Start.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Control_Power_Start.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Control_Power_Start.MSG_OFFSET + Control_Power_Start.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Control_Power_Start.ID)
            self.hdr.SetDataLength(Control_Power_Start.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Control.Power.Start"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetPowerStart(self, enumAsInt=0):
        """"""
        value = struct.unpack_from('B', self.rawBuffer(), Control_Power_Start.MSG_OFFSET + 0)[0]
        if not enumAsInt:
            value = Control_Power_Start.ReversePowerStatus.get(value, value)
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('65535')
    @msg.offset('1')
    @msg.size('2')
    @msg.count(1)
    def GetUSBDisconnectTimeOut(self):
        """This field is used only when the PowerStart field is set to BMAP_CTRL_PWROFF_ON_USB_DISCON. This field indicates the maximum timeout for USB to be disconnected, at which power down will be initiated. If USB is not removed before the timeout expires, power down will not be initiated."""
        value = struct.unpack_from('>H', self.rawBuffer(), Control_Power_Start.MSG_OFFSET + 1)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetPowerStart(self, value):
        """"""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Control_Power_Start.PowerStatus.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Control_Power_Start.MSG_OFFSET + 0, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('65535')
    @msg.offset('1')
    @msg.size('2')
    @msg.count(1)
    def SetUSBDisconnectTimeOut(self, value):
        """This field is used only when the PowerStart field is set to BMAP_CTRL_PWROFF_ON_USB_DISCON. This field indicates the maximum timeout for USB to be disconnected, at which power down will be initiated. If USB is not removed before the timeout expires, power down will not be initiated."""
        tmp = min(max(value, 0), 65535)
        struct.pack_into('>H', self.rawBuffer(), Control_Power_Start.MSG_OFFSET + 1, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="PowerStart",type="enumeration",units="",minVal="0",maxVal="255",description="",get=GetPowerStart,set=SetPowerStart,count=1, bitfieldInfo = [], enum = [PowerStatus, ReversePowerStatus]),\
        FieldInfo(name="USBDisconnectTimeOut",type="int",units="",minVal="0",maxVal="65535",description="This field is used only when the PowerStart field is set to BMAP_CTRL_PWROFF_ON_USB_DISCON. This field indicates the maximum timeout for USB to be disconnected, at which power down will be initiated. If USB is not removed before the timeout expires, power down will not be initiated.",get=GetUSBDisconnectTimeOut,set=SetUSBDisconnectTimeOut,count=1, bitfieldInfo = [], enum = [])\
    ]

Messaging.Register("Control.Power.Start", Control_Power_Start.ID, Control_Power_Start)
#    obj/CodeGenerator/Python/Control/Power.py
#    Created 27/07/2023 at 10:10:01 from:
#        Messages = messages/Control/Power.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Control_Power_Processing :
    ID = 28743
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 7), ("Function", 4), ("Operator", 7)])
    ReverseIDs = OrderedDict([(7, "FunctionBlock"), (4, "Function"), (7, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Control_Power_Processing.MSG_OFFSET + Control_Power_Processing.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Control_Power_Processing.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Control_Power_Processing.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Control_Power_Processing.MSG_OFFSET + Control_Power_Processing.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Control_Power_Processing.ID)
            self.hdr.SetDataLength(Control_Power_Processing.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Control.Power.Processing"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("Control.Power.Processing", Control_Power_Processing.ID, Control_Power_Processing)
#    obj/CodeGenerator/Python/Control/Power.py
#    Created 27/07/2023 at 10:10:01 from:
#        Messages = messages/Control/Power.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Control_Power_Result :
    ID = 28742
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 7), ("Function", 4), ("Operator", 6)])
    ReverseIDs = OrderedDict([(7, "FunctionBlock"), (4, "Function"), (6, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Control_Power_Result.MSG_OFFSET + Control_Power_Result.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Control_Power_Result.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Control_Power_Result.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Control_Power_Result.MSG_OFFSET + Control_Power_Result.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Control_Power_Result.ID)
            self.hdr.SetDataLength(Control_Power_Result.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Control.Power.Result"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("Control.Power.Result", Control_Power_Result.ID, Control_Power_Result)
#    obj/CodeGenerator/Python/Control/Power.py
#    Created 27/07/2023 at 10:10:01 from:
#        Messages = messages/Control/Power.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Control_Power_Error :
    ID = 28740
    SIZE = 1
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    ErrorResponseCodes = OrderedDict([("Length", 1), ("Checksum", 2), ("FBlockNotSupported", 3), ("FunctionNotSupported", 4), ("OperatorNotSupported", 5), ("InvalidData", 6), ("DataNotAvailable", 7), ("RunTime", 8), ("Timeout", 9), ("InvalidState", 10), ("DeviceNotFound", 11), ("Busy", 12), ("UnableToConnectTimeout", 13), ("UnableToConnectSourceDeviceKeyMissing", 14), ("OTAFirmwareUpdateInProgress", 15), ("LowBatteryVoltage", 16), ("ChargerNotConnected", 17), ("UpdateNotAllowed", 18), ("UnknownPortNumber", 19), ("InsecureTransport", 20), ("InvalidOTPKey", 21), ("OutOfMemory", 22), ("CryptoProcessingError", 23), ("FeatureLocked", 24), ("FunctionBlockSpecificErrorCode", 255)])
    ReverseErrorResponseCodes = OrderedDict([(1, "Length"), (2, "Checksum"), (3, "FBlockNotSupported"), (4, "FunctionNotSupported"), (5, "OperatorNotSupported"), (6, "InvalidData"), (7, "DataNotAvailable"), (8, "RunTime"), (9, "Timeout"), (10, "InvalidState"), (11, "DeviceNotFound"), (12, "Busy"), (13, "UnableToConnectTimeout"), (14, "UnableToConnectSourceDeviceKeyMissing"), (15, "OTAFirmwareUpdateInProgress"), (16, "LowBatteryVoltage"), (17, "ChargerNotConnected"), (18, "UpdateNotAllowed"), (19, "UnknownPortNumber"), (20, "InsecureTransport"), (21, "InvalidOTPKey"), (22, "OutOfMemory"), (23, "CryptoProcessingError"), (24, "FeatureLocked"), (255, "FunctionBlockSpecificErrorCode")])
    IDs = OrderedDict([("FunctionBlock", 7), ("Function", 4), ("Operator", 4)])
    ReverseIDs = OrderedDict([(7, "FunctionBlock"), (4, "Function"), (4, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Control_Power_Error.MSG_OFFSET + Control_Power_Error.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Control_Power_Error.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Control_Power_Error.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Control_Power_Error.MSG_OFFSET + Control_Power_Error.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Control_Power_Error.ID)
            self.hdr.SetDataLength(Control_Power_Error.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Control.Power.Error"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetErrorResponseCodes(self, enumAsInt=0):
        """"""
        value = struct.unpack_from('B', self.rawBuffer(), Control_Power_Error.MSG_OFFSET + 0)[0]
        if not enumAsInt:
            value = Control_Power_Error.ReverseErrorResponseCodes.get(value, value)
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetErrorResponseCodes(self, value):
        """"""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Control_Power_Error.ErrorResponseCodes.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Control_Power_Error.MSG_OFFSET + 0, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="ErrorResponseCodes",type="enumeration",units="",minVal="0",maxVal="255",description="",get=GetErrorResponseCodes,set=SetErrorResponseCodes,count=1, bitfieldInfo = [], enum = [ErrorResponseCodes, ReverseErrorResponseCodes])\
    ]

Messaging.Register("Control.Power.Error", Control_Power_Error.ID, Control_Power_Error)
