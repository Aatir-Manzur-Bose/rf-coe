#    obj/CodeGenerator/Python/Control/GetAll.py
#    Created 27/07/2023 at 10:10:01 from:
#        Messages = messages/Control/GetAll.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Control_GetAll_Start :
    ID = 28693
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 7), ("Function", 1), ("Operator", 5)])
    ReverseIDs = OrderedDict([(7, "FunctionBlock"), (1, "Function"), (5, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Control_GetAll_Start.MSG_OFFSET + Control_GetAll_Start.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Control_GetAll_Start.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Control_GetAll_Start.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Control_GetAll_Start.MSG_OFFSET + Control_GetAll_Start.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Control_GetAll_Start.ID)
            self.hdr.SetDataLength(Control_GetAll_Start.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Control.GetAll.Start"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("Control.GetAll.Start", Control_GetAll_Start.ID, Control_GetAll_Start)
#    obj/CodeGenerator/Python/Control/GetAll.py
#    Created 27/07/2023 at 10:10:01 from:
#        Messages = messages/Control/GetAll.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Control_GetAll_Get :
    ID = 28689
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 7), ("Function", 1), ("Operator", 1)])
    ReverseIDs = OrderedDict([(7, "FunctionBlock"), (1, "Function"), (1, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Control_GetAll_Get.MSG_OFFSET + Control_GetAll_Get.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Control_GetAll_Get.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Control_GetAll_Get.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Control_GetAll_Get.MSG_OFFSET + Control_GetAll_Get.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Control_GetAll_Get.ID)
            self.hdr.SetDataLength(Control_GetAll_Get.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Control.GetAll.Get"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("Control.GetAll.Get", Control_GetAll_Get.ID, Control_GetAll_Get)
#    obj/CodeGenerator/Python/Control/GetAll.py
#    Created 27/07/2023 at 10:10:01 from:
#        Messages = messages/Control/GetAll.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Control_GetAll_Processing :
    ID = 28695
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 7), ("Function", 1), ("Operator", 7)])
    ReverseIDs = OrderedDict([(7, "FunctionBlock"), (1, "Function"), (7, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Control_GetAll_Processing.MSG_OFFSET + Control_GetAll_Processing.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Control_GetAll_Processing.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Control_GetAll_Processing.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Control_GetAll_Processing.MSG_OFFSET + Control_GetAll_Processing.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Control_GetAll_Processing.ID)
            self.hdr.SetDataLength(Control_GetAll_Processing.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Control.GetAll.Processing"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("Control.GetAll.Processing", Control_GetAll_Processing.ID, Control_GetAll_Processing)
#    obj/CodeGenerator/Python/Control/GetAll.py
#    Created 27/07/2023 at 10:10:01 from:
#        Messages = messages/Control/GetAll.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Control_GetAll_Result :
    ID = 28694
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 7), ("Function", 1), ("Operator", 6)])
    ReverseIDs = OrderedDict([(7, "FunctionBlock"), (1, "Function"), (6, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Control_GetAll_Result.MSG_OFFSET + Control_GetAll_Result.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Control_GetAll_Result.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Control_GetAll_Result.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Control_GetAll_Result.MSG_OFFSET + Control_GetAll_Result.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Control_GetAll_Result.ID)
            self.hdr.SetDataLength(Control_GetAll_Result.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Control.GetAll.Result"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("Control.GetAll.Result", Control_GetAll_Result.ID, Control_GetAll_Result)
#    obj/CodeGenerator/Python/Control/GetAll.py
#    Created 27/07/2023 at 10:10:01 from:
#        Messages = messages/Control/GetAll.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Control_GetAll_Status :
    ID = 28691
    SIZE = 1
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 7), ("Function", 1), ("Operator", 3)])
    ReverseIDs = OrderedDict([(7, "FunctionBlock"), (1, "Function"), (3, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Control_GetAll_Status.MSG_OFFSET + Control_GetAll_Status.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Control_GetAll_Status.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Control_GetAll_Status.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Control_GetAll_Status.MSG_OFFSET + Control_GetAll_Status.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Control_GetAll_Status.ID)
            self.hdr.SetDataLength(Control_GetAll_Status.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Control.GetAll.Status"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetSupportedFunctions(self):
        """Bitfield of supported functions. The bitfield of supported functions is of variable length, dictated by the highest function ID that is supported.  If the highest function ID is 7, for instance, the product with only send one byte in its response and truncate the MSB's that would be all 0's."""
        value = struct.unpack_from('B', self.rawBuffer(), Control_GetAll_Status.MSG_OFFSET + 0)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetSupportedFunctions(self, value):
        """Bitfield of supported functions. The bitfield of supported functions is of variable length, dictated by the highest function ID that is supported.  If the highest function ID is 7, for instance, the product with only send one byte in its response and truncate the MSB's that would be all 0's."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Control_GetAll_Status.MSG_OFFSET + 0, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="SupportedFunctions",type="int",units="",minVal="0",maxVal="255",description="Bitfield of supported functions. The bitfield of supported functions is of variable length, dictated by the highest function ID that is supported.  If the highest function ID is 7, for instance, the product with only send one byte in its response and truncate the MSB's that would be all 0's.",get=GetSupportedFunctions,set=SetSupportedFunctions,count=1, bitfieldInfo = [], enum = [])\
    ]

Messaging.Register("Control.GetAll.Status", Control_GetAll_Status.ID, Control_GetAll_Status)
#    obj/CodeGenerator/Python/Control/GetAll.py
#    Created 27/07/2023 at 10:10:01 from:
#        Messages = messages/Control/GetAll.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Control_GetAll_Error :
    ID = 28692
    SIZE = 1
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 7), ("Function", 1), ("Operator", 4)])
    ReverseIDs = OrderedDict([(7, "FunctionBlock"), (1, "Function"), (4, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Control_GetAll_Error.MSG_OFFSET + Control_GetAll_Error.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Control_GetAll_Error.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Control_GetAll_Error.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Control_GetAll_Error.MSG_OFFSET + Control_GetAll_Error.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Control_GetAll_Error.ID)
            self.hdr.SetDataLength(Control_GetAll_Error.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Control.GetAll.Error"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetBusy(self):
        """A busy error will be sent if the product is already processing a response to a GetAll command"""
        value = struct.unpack_from('B', self.rawBuffer(), Control_GetAll_Error.MSG_OFFSET + 0)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetBusy(self, value):
        """A busy error will be sent if the product is already processing a response to a GetAll command"""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Control_GetAll_Error.MSG_OFFSET + 0, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="Busy",type="int",units="",minVal="0",maxVal="255",description="A busy error will be sent if the product is already processing a response to a GetAll command",get=GetBusy,set=SetBusy,count=1, bitfieldInfo = [], enum = [])\
    ]

Messaging.Register("Control.GetAll.Error", Control_GetAll_Error.ID, Control_GetAll_Error)
