#    obj/CodeGenerator/Python/Settings/VoicePrompts.py
#    Created 27/07/2023 at 10:11:09 from:
#        Messages = messages/Settings/VoicePrompts.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Settings_VoicePrompts_Get :
    ID = 4145
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 1), ("Function", 3), ("Operator", 1)])
    ReverseIDs = OrderedDict([(1, "FunctionBlock"), (3, "Function"), (1, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Settings_VoicePrompts_Get.MSG_OFFSET + Settings_VoicePrompts_Get.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Settings_VoicePrompts_Get.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Settings_VoicePrompts_Get.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Settings_VoicePrompts_Get.MSG_OFFSET + Settings_VoicePrompts_Get.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Settings_VoicePrompts_Get.ID)
            self.hdr.SetDataLength(Settings_VoicePrompts_Get.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Settings.VoicePrompts.Get"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("Settings.VoicePrompts.Get", Settings_VoicePrompts_Get.ID, Settings_VoicePrompts_Get)
#    obj/CodeGenerator/Python/Settings/VoicePrompts.py
#    Created 27/07/2023 at 10:11:09 from:
#        Messages = messages/Settings/VoicePrompts.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Settings_VoicePrompts_SetGet :
    ID = 4146
    SIZE = 2
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    Languages = OrderedDict([("UKEnglish", 0), ("USEnglish", 1), ("French", 2), ("Italian", 3), ("German", 4), ("EuropeanSpanish", 5), ("MexicanSpanish", 6), ("BrazilianPortuguese", 7), ("MandarinChinese", 8), ("Korean", 9), ("Russian", 10), ("Polish", 11), ("Hebrew", 12), ("Turkish", 13), ("Dutch", 14), ("Japanese", 15), ("Cantonese", 16), ("Arabic", 17), ("Swedish", 18), ("Danish", 19), ("Norwegian", 20), ("Finnish", 21), ("Hindi", 22)])
    ReverseLanguages = OrderedDict([(0, "UKEnglish"), (1, "USEnglish"), (2, "French"), (3, "Italian"), (4, "German"), (5, "EuropeanSpanish"), (6, "MexicanSpanish"), (7, "BrazilianPortuguese"), (8, "MandarinChinese"), (9, "Korean"), (10, "Russian"), (11, "Polish"), (12, "Hebrew"), (13, "Turkish"), (14, "Dutch"), (15, "Japanese"), (16, "Cantonese"), (17, "Arabic"), (18, "Swedish"), (19, "Danish"), (20, "Norwegian"), (21, "Finnish"), (22, "Hindi")])
    IDs = OrderedDict([("FunctionBlock", 1), ("Function", 3), ("Operator", 2)])
    ReverseIDs = OrderedDict([(1, "FunctionBlock"), (3, "Function"), (2, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Settings_VoicePrompts_SetGet.MSG_OFFSET + Settings_VoicePrompts_SetGet.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Settings_VoicePrompts_SetGet.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Settings_VoicePrompts_SetGet.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Settings_VoicePrompts_SetGet.MSG_OFFSET + Settings_VoicePrompts_SetGet.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Settings_VoicePrompts_SetGet.ID)
            self.hdr.SetDataLength(Settings_VoicePrompts_SetGet.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Settings.VoicePrompts.SetGet"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetConfiguration(self):
        """Set/Get VoicePrompts."""
        value = struct.unpack_from('B', self.rawBuffer(), Settings_VoicePrompts_SetGet.MSG_OFFSET + 0)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('31')
    @msg.offset('0')
    @msg.size('0')
    @msg.count(1)
    def GetCurrentLanguage(self, enumAsInt=0):
        """Currently supported languages"""
        value = (self.GetConfiguration() >> 0) & 0x1f
        if not enumAsInt:
            value = Settings_VoicePrompts_SetGet.ReverseLanguages.get(value, value)
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('0')
    @msg.size('0')
    @msg.count(1)
    def GetPromptEnable(self):
        """Prompt enable flag"""
        value = (self.GetConfiguration() >> 5) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('1')
    @msg.size('1')
    @msg.count(1)
    def GetVoicePromptFeatures(self):
        """Optional byte to further customize VoicePrompts."""
        value = struct.unpack_from('B', self.rawBuffer(), Settings_VoicePrompts_SetGet.MSG_OFFSET + 1)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetEnablePowerOnBatteryVP(self):
        """If enabled, battery information will be played when power on or exiting hibernation. (1 == enabled, 0 == disabled)"""
        value = (self.GetVoicePromptFeatures() >> 0) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('127')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetUnused(self):
        """Bits reserved for future"""
        value = (self.GetVoicePromptFeatures() >> 1) & 0x7f
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetConfiguration(self, value):
        """Set/Get VoicePrompts."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Settings_VoicePrompts_SetGet.MSG_OFFSET + 0, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('31')
    @msg.offset('0')
    @msg.size('0')
    @msg.count(1)
    def SetCurrentLanguage(self, value):
        """Currently supported languages"""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Settings_VoicePrompts_SetGet.Languages.get(value, defaultValue)
        tmp = min(max(value, 0), 31)
        self.SetConfiguration((self.GetConfiguration() & ~(0x1f << 0)) | ((tmp & 0x1f) << 0))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('0')
    @msg.size('0')
    @msg.count(1)
    def SetPromptEnable(self, value):
        """Prompt enable flag"""
        tmp = min(max(value, 0), 1)
        self.SetConfiguration((self.GetConfiguration() & ~(0x1 << 5)) | ((tmp & 0x1) << 5))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('1')
    @msg.size('1')
    @msg.count(1)
    def SetVoicePromptFeatures(self, value):
        """Optional byte to further customize VoicePrompts."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Settings_VoicePrompts_SetGet.MSG_OFFSET + 1, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetEnablePowerOnBatteryVP(self, value):
        """If enabled, battery information will be played when power on or exiting hibernation. (1 == enabled, 0 == disabled)"""
        tmp = min(max(value, 0), 1)
        self.SetVoicePromptFeatures((self.GetVoicePromptFeatures() & ~(0x1 << 0)) | ((tmp & 0x1) << 0))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('127')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetUnused(self, value):
        """Bits reserved for future"""
        tmp = min(max(value, 0), 127)
        self.SetVoicePromptFeatures((self.GetVoicePromptFeatures() & ~(0x7f << 1)) | ((tmp & 0x7f) << 1))
    

    # Reflection information
    fields = [ \
        FieldInfo(name="Configuration",type="int",units="",minVal="0",maxVal="255",description="Set/Get VoicePrompts.",get=GetConfiguration,set=SetConfiguration,count=1, bitfieldInfo = [\
            BitFieldInfo(name="CurrentLanguage",type="enumeration",units="",minVal="0",maxVal="31",description="Currently supported languages",get=GetCurrentLanguage,set=SetCurrentLanguage, enum = [Languages, ReverseLanguages]),\
            BitFieldInfo(name="PromptEnable",type="int",units="",minVal="0",maxVal="1",description="Prompt enable flag",get=GetPromptEnable,set=SetPromptEnable, enum = [])], enum = []),\
        FieldInfo(name="VoicePromptFeatures",type="int",units="",minVal="0",maxVal="255",description="Optional byte to further customize VoicePrompts.",get=GetVoicePromptFeatures,set=SetVoicePromptFeatures,count=1, bitfieldInfo = [\
            BitFieldInfo(name="EnablePowerOnBatteryVP",type="int",units="",minVal="0",maxVal="1",description="If enabled, battery information will be played when power on or exiting hibernation. (1 == enabled, 0 == disabled)",get=GetEnablePowerOnBatteryVP,set=SetEnablePowerOnBatteryVP, enum = []),\
            BitFieldInfo(name="Unused",type="int",units="",minVal="0",maxVal="127",description="Bits reserved for future",get=GetUnused,set=SetUnused, enum = [])], enum = [])\
    ]

Messaging.Register("Settings.VoicePrompts.SetGet", Settings_VoicePrompts_SetGet.ID, Settings_VoicePrompts_SetGet)
#    obj/CodeGenerator/Python/Settings/VoicePrompts.py
#    Created 27/07/2023 at 10:11:09 from:
#        Messages = messages/Settings/VoicePrompts.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Settings_VoicePrompts_Status :
    ID = 4147
    SIZE = 7
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    Languages = OrderedDict([("UKEnglish", 0), ("USEnglish", 1), ("French", 2), ("Italian", 3), ("German", 4), ("EuropeanSpanish", 5), ("MexicanSpanish", 6), ("BrazilianPortuguese", 7), ("MandarinChinese", 8), ("Korean", 9), ("Russian", 10), ("Polish", 11), ("Hebrew", 12), ("Turkish", 13), ("Dutch", 14), ("Japanese", 15), ("Cantonese", 16), ("Arabic", 17), ("Swedish", 18), ("Danish", 19), ("Norwegian", 20), ("Finnish", 21), ("Hindi", 22)])
    ReverseLanguages = OrderedDict([(0, "UKEnglish"), (1, "USEnglish"), (2, "French"), (3, "Italian"), (4, "German"), (5, "EuropeanSpanish"), (6, "MexicanSpanish"), (7, "BrazilianPortuguese"), (8, "MandarinChinese"), (9, "Korean"), (10, "Russian"), (11, "Polish"), (12, "Hebrew"), (13, "Turkish"), (14, "Dutch"), (15, "Japanese"), (16, "Cantonese"), (17, "Arabic"), (18, "Swedish"), (19, "Danish"), (20, "Norwegian"), (21, "Finnish"), (22, "Hindi")])
    IDs = OrderedDict([("FunctionBlock", 1), ("Function", 3), ("Operator", 3)])
    ReverseIDs = OrderedDict([(1, "FunctionBlock"), (3, "Function"), (3, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Settings_VoicePrompts_Status.MSG_OFFSET + Settings_VoicePrompts_Status.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Settings_VoicePrompts_Status.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Settings_VoicePrompts_Status.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Settings_VoicePrompts_Status.MSG_OFFSET + Settings_VoicePrompts_Status.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Settings_VoicePrompts_Status.ID)
            self.hdr.SetDataLength(Settings_VoicePrompts_Status.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Settings.VoicePrompts.Status"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetConfiguration(self):
        """"""
        value = struct.unpack_from('B', self.rawBuffer(), Settings_VoicePrompts_Status.MSG_OFFSET + 0)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('31')
    @msg.offset('0')
    @msg.size('0')
    @msg.count(1)
    def GetCurrentLanguage(self, enumAsInt=0):
        """Currently supported languages"""
        value = (self.GetConfiguration() >> 0) & 0x1f
        if not enumAsInt:
            value = Settings_VoicePrompts_Status.ReverseLanguages.get(value, value)
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('0')
    @msg.size('0')
    @msg.count(1)
    def GetPromptEnable(self):
        """Prompt enable flag"""
        value = (self.GetConfiguration() >> 5) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('0')
    @msg.size('0')
    @msg.count(1)
    def GetLanguageMatchesDefault(self):
        """0 -- voice prompt language has been changed or set by user, 1 -- voice prompt language is default (not changed or set by user)"""
        value = (self.GetConfiguration() >> 6) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('0')
    @msg.size('0')
    @msg.count(1)
    def GetUserEnableOrDisable(self):
        """User can enable/disable (read-only)"""
        value = (self.GetConfiguration() >> 7) & 0x1
        return value
    
    @msg.units('Hex')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('1')
    @msg.size('1')
    @msg.count(4)
    def GetAvailableLanguages(self, idx):
        """Bitfield of available voicepromt languages. Each bit corresponds to the language selection ID specified in the next table.  The bitmask is big endian, with the MSB in byte 1 and the LSB in byte 4.  This field is read-only."""
        value = struct.unpack_from('B', self.rawBuffer(), Settings_VoicePrompts_Status.MSG_OFFSET + 1+idx*1)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('5')
    @msg.size('1')
    @msg.count(1)
    def GetSupportedVoicePromptFeatures(self):
        """Optional byte to indicate what VoicePrompts features are supported on the running firmware. Byte 5 and 6 must exist as a pair."""
        value = struct.unpack_from('B', self.rawBuffer(), Settings_VoicePrompts_Status.MSG_OFFSET + 5)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('5')
    @msg.size('0')
    @msg.count(1)
    def GetEnablePowerOnBatteryVPSupport(self):
        """Indicate whether or not enabling power on battery voice prompt feature is supported (1 == supported, 0 == not supported)."""
        value = (self.GetSupportedVoicePromptFeatures() >> 0) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('127')
    @msg.offset('5')
    @msg.size('0')
    @msg.count(1)
    def GetUnusedSupport(self):
        """Bits reserved for future."""
        value = (self.GetSupportedVoicePromptFeatures() >> 1) & 0x7f
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('6')
    @msg.size('1')
    @msg.count(1)
    def GetVoicePromptFeatures(self):
        """Optional byte to show the status of supported VoicePrompts features."""
        value = struct.unpack_from('B', self.rawBuffer(), Settings_VoicePrompts_Status.MSG_OFFSET + 6)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('6')
    @msg.size('0')
    @msg.count(1)
    def GetEnablePowerOnBatteryVPStatus(self):
        """If enabled, power on battery information voice prompt will be played (1 == enabled, 0 == disabled)."""
        value = (self.GetVoicePromptFeatures() >> 0) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('127')
    @msg.offset('6')
    @msg.size('0')
    @msg.count(1)
    def GetUnusedStatus(self):
        """Bits reserved for future."""
        value = (self.GetVoicePromptFeatures() >> 1) & 0x7f
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetConfiguration(self, value):
        """"""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Settings_VoicePrompts_Status.MSG_OFFSET + 0, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('31')
    @msg.offset('0')
    @msg.size('0')
    @msg.count(1)
    def SetCurrentLanguage(self, value):
        """Currently supported languages"""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Settings_VoicePrompts_Status.Languages.get(value, defaultValue)
        tmp = min(max(value, 0), 31)
        self.SetConfiguration((self.GetConfiguration() & ~(0x1f << 0)) | ((tmp & 0x1f) << 0))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('0')
    @msg.size('0')
    @msg.count(1)
    def SetPromptEnable(self, value):
        """Prompt enable flag"""
        tmp = min(max(value, 0), 1)
        self.SetConfiguration((self.GetConfiguration() & ~(0x1 << 5)) | ((tmp & 0x1) << 5))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('0')
    @msg.size('0')
    @msg.count(1)
    def SetLanguageMatchesDefault(self, value):
        """0 -- voice prompt language has been changed or set by user, 1 -- voice prompt language is default (not changed or set by user)"""
        tmp = min(max(value, 0), 1)
        self.SetConfiguration((self.GetConfiguration() & ~(0x1 << 6)) | ((tmp & 0x1) << 6))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('0')
    @msg.size('0')
    @msg.count(1)
    def SetUserEnableOrDisable(self, value):
        """User can enable/disable (read-only)"""
        tmp = min(max(value, 0), 1)
        self.SetConfiguration((self.GetConfiguration() & ~(0x1 << 7)) | ((tmp & 0x1) << 7))
    
    @msg.units('Hex')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('1')
    @msg.size('1')
    @msg.count(4)
    def SetAvailableLanguages(self, value, idx):
        """Bitfield of available voicepromt languages. Each bit corresponds to the language selection ID specified in the next table.  The bitmask is big endian, with the MSB in byte 1 and the LSB in byte 4.  This field is read-only."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Settings_VoicePrompts_Status.MSG_OFFSET + 1+idx*1, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('5')
    @msg.size('1')
    @msg.count(1)
    def SetSupportedVoicePromptFeatures(self, value):
        """Optional byte to indicate what VoicePrompts features are supported on the running firmware. Byte 5 and 6 must exist as a pair."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Settings_VoicePrompts_Status.MSG_OFFSET + 5, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('5')
    @msg.size('0')
    @msg.count(1)
    def SetEnablePowerOnBatteryVPSupport(self, value):
        """Indicate whether or not enabling power on battery voice prompt feature is supported (1 == supported, 0 == not supported)."""
        tmp = min(max(value, 0), 1)
        self.SetSupportedVoicePromptFeatures((self.GetSupportedVoicePromptFeatures() & ~(0x1 << 0)) | ((tmp & 0x1) << 0))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('127')
    @msg.offset('5')
    @msg.size('0')
    @msg.count(1)
    def SetUnusedSupport(self, value):
        """Bits reserved for future."""
        tmp = min(max(value, 0), 127)
        self.SetSupportedVoicePromptFeatures((self.GetSupportedVoicePromptFeatures() & ~(0x7f << 1)) | ((tmp & 0x7f) << 1))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('6')
    @msg.size('1')
    @msg.count(1)
    def SetVoicePromptFeatures(self, value):
        """Optional byte to show the status of supported VoicePrompts features."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Settings_VoicePrompts_Status.MSG_OFFSET + 6, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('6')
    @msg.size('0')
    @msg.count(1)
    def SetEnablePowerOnBatteryVPStatus(self, value):
        """If enabled, power on battery information voice prompt will be played (1 == enabled, 0 == disabled)."""
        tmp = min(max(value, 0), 1)
        self.SetVoicePromptFeatures((self.GetVoicePromptFeatures() & ~(0x1 << 0)) | ((tmp & 0x1) << 0))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('127')
    @msg.offset('6')
    @msg.size('0')
    @msg.count(1)
    def SetUnusedStatus(self, value):
        """Bits reserved for future."""
        tmp = min(max(value, 0), 127)
        self.SetVoicePromptFeatures((self.GetVoicePromptFeatures() & ~(0x7f << 1)) | ((tmp & 0x7f) << 1))
    

    # Reflection information
    fields = [ \
        FieldInfo(name="Configuration",type="int",units="",minVal="0",maxVal="255",description="",get=GetConfiguration,set=SetConfiguration,count=1, bitfieldInfo = [\
            BitFieldInfo(name="CurrentLanguage",type="enumeration",units="",minVal="0",maxVal="31",description="Currently supported languages",get=GetCurrentLanguage,set=SetCurrentLanguage, enum = [Languages, ReverseLanguages]),\
            BitFieldInfo(name="PromptEnable",type="int",units="",minVal="0",maxVal="1",description="Prompt enable flag",get=GetPromptEnable,set=SetPromptEnable, enum = []),\
            BitFieldInfo(name="LanguageMatchesDefault",type="int",units="",minVal="0",maxVal="1",description="0 -- voice prompt language has been changed or set by user, 1 -- voice prompt language is default (not changed or set by user)",get=GetLanguageMatchesDefault,set=SetLanguageMatchesDefault, enum = []),\
            BitFieldInfo(name="UserEnableOrDisable",type="int",units="",minVal="0",maxVal="1",description="User can enable/disable (read-only)",get=GetUserEnableOrDisable,set=SetUserEnableOrDisable, enum = [])], enum = []),\
        FieldInfo(name="AvailableLanguages",type="int",units="Hex",minVal="0",maxVal="255",description="Bitfield of available voicepromt languages. Each bit corresponds to the language selection ID specified in the next table.  The bitmask is big endian, with the MSB in byte 1 and the LSB in byte 4.  This field is read-only.",get=GetAvailableLanguages,set=SetAvailableLanguages,count=4, bitfieldInfo = [], enum = []),\
        FieldInfo(name="SupportedVoicePromptFeatures",type="int",units="",minVal="0",maxVal="255",description="Optional byte to indicate what VoicePrompts features are supported on the running firmware. Byte 5 and 6 must exist as a pair.",get=GetSupportedVoicePromptFeatures,set=SetSupportedVoicePromptFeatures,count=1, bitfieldInfo = [\
            BitFieldInfo(name="EnablePowerOnBatteryVPSupport",type="int",units="",minVal="0",maxVal="1",description="Indicate whether or not enabling power on battery voice prompt feature is supported (1 == supported, 0 == not supported).",get=GetEnablePowerOnBatteryVPSupport,set=SetEnablePowerOnBatteryVPSupport, enum = []),\
            BitFieldInfo(name="UnusedSupport",type="int",units="",minVal="0",maxVal="127",description="Bits reserved for future.",get=GetUnusedSupport,set=SetUnusedSupport, enum = [])], enum = []),\
        FieldInfo(name="VoicePromptFeatures",type="int",units="",minVal="0",maxVal="255",description="Optional byte to show the status of supported VoicePrompts features.",get=GetVoicePromptFeatures,set=SetVoicePromptFeatures,count=1, bitfieldInfo = [\
            BitFieldInfo(name="EnablePowerOnBatteryVPStatus",type="int",units="",minVal="0",maxVal="1",description="If enabled, power on battery information voice prompt will be played (1 == enabled, 0 == disabled).",get=GetEnablePowerOnBatteryVPStatus,set=SetEnablePowerOnBatteryVPStatus, enum = []),\
            BitFieldInfo(name="UnusedStatus",type="int",units="",minVal="0",maxVal="127",description="Bits reserved for future.",get=GetUnusedStatus,set=SetUnusedStatus, enum = [])], enum = [])\
    ]

Messaging.Register("Settings.VoicePrompts.Status", Settings_VoicePrompts_Status.ID, Settings_VoicePrompts_Status)
