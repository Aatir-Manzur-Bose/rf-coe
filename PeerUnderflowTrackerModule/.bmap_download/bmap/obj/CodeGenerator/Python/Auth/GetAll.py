#    obj/CodeGenerator/Python/Auth/GetAll.py
#    Created 27/07/2023 at 10:09:44 from:
#        Messages = messages/Auth/GetAll.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Auth_GetAll_Get :
    ID = 73745
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 18), ("Function", 1), ("Operator", 1)])
    ReverseIDs = OrderedDict([(18, "FunctionBlock"), (1, "Function"), (1, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Auth_GetAll_Get.MSG_OFFSET + Auth_GetAll_Get.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Auth_GetAll_Get.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Auth_GetAll_Get.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Auth_GetAll_Get.MSG_OFFSET + Auth_GetAll_Get.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Auth_GetAll_Get.ID)
            self.hdr.SetDataLength(Auth_GetAll_Get.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Auth.GetAll.Get"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("Auth.GetAll.Get", Auth_GetAll_Get.ID, Auth_GetAll_Get)
#    obj/CodeGenerator/Python/Auth/GetAll.py
#    Created 27/07/2023 at 10:09:44 from:
#        Messages = messages/Auth/GetAll.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Auth_GetAll_Status :
    ID = 73747
    SIZE = 1
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 18), ("Function", 1), ("Operator", 3)])
    ReverseIDs = OrderedDict([(18, "FunctionBlock"), (1, "Function"), (3, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Auth_GetAll_Status.MSG_OFFSET + Auth_GetAll_Status.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Auth_GetAll_Status.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Auth_GetAll_Status.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Auth_GetAll_Status.MSG_OFFSET + Auth_GetAll_Status.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Auth_GetAll_Status.ID)
            self.hdr.SetDataLength(Auth_GetAll_Status.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Auth.GetAll.Status"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetSupportedFunctions(self):
        """Bitfield of supported functions. The bitfield of supported functions is of variable length, dictated by the highest function ID that is supported.  If the highest function ID is 7, for instance, the product with only send one byte in its response and truncate the MSB's that would be all 0's."""
        value = struct.unpack_from('B', self.rawBuffer(), Auth_GetAll_Status.MSG_OFFSET + 0)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetSupportedFunctions(self, value):
        """Bitfield of supported functions. The bitfield of supported functions is of variable length, dictated by the highest function ID that is supported.  If the highest function ID is 7, for instance, the product with only send one byte in its response and truncate the MSB's that would be all 0's."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Auth_GetAll_Status.MSG_OFFSET + 0, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="SupportedFunctions",type="int",units="",minVal="0",maxVal="255",description="Bitfield of supported functions. The bitfield of supported functions is of variable length, dictated by the highest function ID that is supported.  If the highest function ID is 7, for instance, the product with only send one byte in its response and truncate the MSB's that would be all 0's.",get=GetSupportedFunctions,set=SetSupportedFunctions,count=1, bitfieldInfo = [], enum = [])\
    ]

Messaging.Register("Auth.GetAll.Status", Auth_GetAll_Status.ID, Auth_GetAll_Status)
