#    obj/CodeGenerator/Python/Auth/FeatureLock.py
#    Created 27/07/2023 at 10:09:43 from:
#        Messages = messages/Auth/FeatureLock.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Auth_FeatureLock_Get :
    ID = 73889
    SIZE = 1
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    FeatureLockType = OrderedDict([("temporarily_unlocked", 0), ("temporarily_locked", 1), ("persistently_unlocked", 2), ("persistently_locked", 3)])
    ReverseFeatureLockType = OrderedDict([(0, "temporarily_unlocked"), (1, "temporarily_locked"), (2, "persistently_unlocked"), (3, "persistently_locked")])
    IDs = OrderedDict([("FunctionBlock", 18), ("Function", 10), ("Operator", 1)])
    ReverseIDs = OrderedDict([(18, "FunctionBlock"), (10, "Function"), (1, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Auth_FeatureLock_Get.MSG_OFFSET + Auth_FeatureLock_Get.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Auth_FeatureLock_Get.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Auth_FeatureLock_Get.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Auth_FeatureLock_Get.MSG_OFFSET + Auth_FeatureLock_Get.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Auth_FeatureLock_Get.ID)
            self.hdr.SetDataLength(Auth_FeatureLock_Get.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Auth.FeatureLock.Get"
    # Accessors
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetQueryType(self, enumAsInt=0):
        """See the description of  textbf{FeatureLockType} enum."""
        value = struct.unpack_from('B', self.rawBuffer(), Auth_FeatureLock_Get.MSG_OFFSET + 0)[0]
        if not enumAsInt:
            value = Auth_FeatureLock_Get.ReverseFeatureLockType.get(value, value)
        return value
    
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetQueryType(self, value):
        """See the description of  textbf{FeatureLockType} enum."""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Auth_FeatureLock_Get.FeatureLockType.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Auth_FeatureLock_Get.MSG_OFFSET + 0, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="QueryType",type="enumeration",units="Enum",minVal="0",maxVal="255",description="See the description of  textbf{FeatureLockType} enum.",get=GetQueryType,set=SetQueryType,count=1, bitfieldInfo = [], enum = [FeatureLockType, ReverseFeatureLockType])\
    ]

Messaging.Register("Auth.FeatureLock.Get", Auth_FeatureLock_Get.ID, Auth_FeatureLock_Get)
#    obj/CodeGenerator/Python/Auth/FeatureLock.py
#    Created 27/07/2023 at 10:09:43 from:
#        Messages = messages/Auth/FeatureLock.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Auth_FeatureLock_Status :
    ID = 73891
    SIZE = 3
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    FeatureLockType = OrderedDict([("temporarily_unlocked", 0), ("temporarily_locked", 1), ("persistently_unlocked", 2), ("persistently_locked", 3)])
    ReverseFeatureLockType = OrderedDict([(0, "temporarily_unlocked"), (1, "temporarily_locked"), (2, "persistently_unlocked"), (3, "persistently_locked")])
    IDs = OrderedDict([("FunctionBlock", 18), ("Function", 10), ("Operator", 3)])
    ReverseIDs = OrderedDict([(18, "FunctionBlock"), (10, "Function"), (3, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Auth_FeatureLock_Status.MSG_OFFSET + Auth_FeatureLock_Status.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Auth_FeatureLock_Status.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Auth_FeatureLock_Status.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Auth_FeatureLock_Status.MSG_OFFSET + Auth_FeatureLock_Status.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Auth_FeatureLock_Status.ID)
            self.hdr.SetDataLength(Auth_FeatureLock_Status.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Auth.FeatureLock.Status"
    # Accessors
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetQueryType(self, enumAsInt=0):
        """See the description of  textbf{FeatureLockType} enum."""
        value = struct.unpack_from('B', self.rawBuffer(), Auth_FeatureLock_Status.MSG_OFFSET + 0)[0]
        if not enumAsInt:
            value = Auth_FeatureLock_Status.ReverseFeatureLockType.get(value, value)
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('65535')
    @msg.offset('1')
    @msg.size('2')
    @msg.count(1)
    def GetFeatureState(self):
        """Each bit in the array is mapped to a specific product feature.  If the bit is set, it means that the query result is true (i.e., if queried for temporarily unlocked features, a set bit indicates that the corresponding feature is indeed temporarily unlocked)."""
        value = struct.unpack_from('>H', self.rawBuffer(), Auth_FeatureLock_Status.MSG_OFFSET + 1)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetTAP(self):
        """Query result for TAP feature."""
        value = (self.GetFeatureState() >> 0) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetBMAPDebug(self):
        """Query result for BMAP's debugging fblocks."""
        value = (self.GetFeatureState() >> 1) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetUSBDebug(self):
        """Query result for USBDBG enumeration."""
        value = (self.GetFeatureState() >> 2) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetPersistentUnlockCommand(self):
        """Query result for ability to persistently unlock a feature."""
        value = (self.GetFeatureState() >> 3) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetSecureDebugTransports(self):
        """Query result indicating if or not USBDBG and T-bridge interfaces are secured with OTP key."""
        value = (self.GetFeatureState() >> 4) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('2047')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetUnused(self):
        """Reserved for future features."""
        value = (self.GetFeatureState() >> 5) & 0x7ff
        return value
    
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetQueryType(self, value):
        """See the description of  textbf{FeatureLockType} enum."""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Auth_FeatureLock_Status.FeatureLockType.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Auth_FeatureLock_Status.MSG_OFFSET + 0, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('65535')
    @msg.offset('1')
    @msg.size('2')
    @msg.count(1)
    def SetFeatureState(self, value):
        """Each bit in the array is mapped to a specific product feature.  If the bit is set, it means that the query result is true (i.e., if queried for temporarily unlocked features, a set bit indicates that the corresponding feature is indeed temporarily unlocked)."""
        tmp = min(max(value, 0), 65535)
        struct.pack_into('>H', self.rawBuffer(), Auth_FeatureLock_Status.MSG_OFFSET + 1, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetTAP(self, value):
        """Query result for TAP feature."""
        tmp = min(max(value, 0), 1)
        self.SetFeatureState((self.GetFeatureState() & ~(0x1 << 0)) | ((tmp & 0x1) << 0))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetBMAPDebug(self, value):
        """Query result for BMAP's debugging fblocks."""
        tmp = min(max(value, 0), 1)
        self.SetFeatureState((self.GetFeatureState() & ~(0x1 << 1)) | ((tmp & 0x1) << 1))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetUSBDebug(self, value):
        """Query result for USBDBG enumeration."""
        tmp = min(max(value, 0), 1)
        self.SetFeatureState((self.GetFeatureState() & ~(0x1 << 2)) | ((tmp & 0x1) << 2))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetPersistentUnlockCommand(self, value):
        """Query result for ability to persistently unlock a feature."""
        tmp = min(max(value, 0), 1)
        self.SetFeatureState((self.GetFeatureState() & ~(0x1 << 3)) | ((tmp & 0x1) << 3))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetSecureDebugTransports(self, value):
        """Query result indicating if or not USBDBG and T-bridge interfaces are secured with OTP key."""
        tmp = min(max(value, 0), 1)
        self.SetFeatureState((self.GetFeatureState() & ~(0x1 << 4)) | ((tmp & 0x1) << 4))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('2047')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetUnused(self, value):
        """Reserved for future features."""
        tmp = min(max(value, 0), 2047)
        self.SetFeatureState((self.GetFeatureState() & ~(0x7ff << 5)) | ((tmp & 0x7ff) << 5))
    

    # Reflection information
    fields = [ \
        FieldInfo(name="QueryType",type="enumeration",units="Enum",minVal="0",maxVal="255",description="See the description of  textbf{FeatureLockType} enum.",get=GetQueryType,set=SetQueryType,count=1, bitfieldInfo = [], enum = [FeatureLockType, ReverseFeatureLockType]),\
        FieldInfo(name="FeatureState",type="int",units="",minVal="0",maxVal="65535",description="Each bit in the array is mapped to a specific product feature.  If the bit is set, it means that the query result is true (i.e., if queried for temporarily unlocked features, a set bit indicates that the corresponding feature is indeed temporarily unlocked).",get=GetFeatureState,set=SetFeatureState,count=1, bitfieldInfo = [\
            BitFieldInfo(name="TAP",type="int",units="",minVal="0",maxVal="1",description="Query result for TAP feature.",get=GetTAP,set=SetTAP, enum = []),\
            BitFieldInfo(name="BMAPDebug",type="int",units="",minVal="0",maxVal="1",description="Query result for BMAP's debugging fblocks.",get=GetBMAPDebug,set=SetBMAPDebug, enum = []),\
            BitFieldInfo(name="USBDebug",type="int",units="",minVal="0",maxVal="1",description="Query result for USBDBG enumeration.",get=GetUSBDebug,set=SetUSBDebug, enum = []),\
            BitFieldInfo(name="PersistentUnlockCommand",type="int",units="",minVal="0",maxVal="1",description="Query result for ability to persistently unlock a feature.",get=GetPersistentUnlockCommand,set=SetPersistentUnlockCommand, enum = []),\
            BitFieldInfo(name="SecureDebugTransports",type="int",units="",minVal="0",maxVal="1",description="Query result indicating if or not USBDBG and T-bridge interfaces are secured with OTP key.",get=GetSecureDebugTransports,set=SetSecureDebugTransports, enum = []),\
            BitFieldInfo(name="Unused",type="int",units="",minVal="0",maxVal="2047",description="Reserved for future features.",get=GetUnused,set=SetUnused, enum = [])], enum = [])\
    ]

Messaging.Register("Auth.FeatureLock.Status", Auth_FeatureLock_Status.ID, Auth_FeatureLock_Status)
#    obj/CodeGenerator/Python/Auth/FeatureLock.py
#    Created 27/07/2023 at 10:09:43 from:
#        Messages = messages/Auth/FeatureLock.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Auth_FeatureLock_SetGet :
    ID = 73890
    SIZE = 3
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    FeatureLockType = OrderedDict([("temporarily_unlocked", 0), ("temporarily_locked", 1), ("persistently_unlocked", 2), ("persistently_locked", 3)])
    ReverseFeatureLockType = OrderedDict([(0, "temporarily_unlocked"), (1, "temporarily_locked"), (2, "persistently_unlocked"), (3, "persistently_locked")])
    IDs = OrderedDict([("FunctionBlock", 18), ("Function", 10), ("Operator", 2)])
    ReverseIDs = OrderedDict([(18, "FunctionBlock"), (10, "Function"), (2, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Auth_FeatureLock_SetGet.MSG_OFFSET + Auth_FeatureLock_SetGet.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Auth_FeatureLock_SetGet.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Auth_FeatureLock_SetGet.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Auth_FeatureLock_SetGet.MSG_OFFSET + Auth_FeatureLock_SetGet.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Auth_FeatureLock_SetGet.ID)
            self.hdr.SetDataLength(Auth_FeatureLock_SetGet.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Auth.FeatureLock.SetGet"
    # Accessors
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetAction(self, enumAsInt=0):
        """Specifies what action to take. For more details, see description for enum  textbf{FeatureLockType}."""
        value = struct.unpack_from('B', self.rawBuffer(), Auth_FeatureLock_SetGet.MSG_OFFSET + 0)[0]
        if not enumAsInt:
            value = Auth_FeatureLock_SetGet.ReverseFeatureLockType.get(value, value)
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('65535')
    @msg.offset('1')
    @msg.size('2')
    @msg.count(1)
    def GetFeatures(self):
        """Each bit in the array is mapped to a specific product feature.  If the bit is set, it means that the we will take the specifed action on the associated feature.  If the bit is clear, no action will be taken for that feature."""
        value = struct.unpack_from('>H', self.rawBuffer(), Auth_FeatureLock_SetGet.MSG_OFFSET + 1)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetTAP(self):
        """Lock or unlock the TAP feature."""
        value = (self.GetFeatures() >> 0) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetBMAPDebug(self):
        """Lock or unlock the BMAP Debug FBlocks."""
        value = (self.GetFeatures() >> 1) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetUSBDebug(self):
        """Enable or disable USBDBG enumeration."""
        value = (self.GetFeatures() >> 2) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetPersistentUnlockCommand(self):
        """Enable or disable the ability to persistently unlock a feature."""
        value = (self.GetFeatures() >> 3) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetSecureDebugTransports(self):
        """Secure (restrict) access to USBDBG and T-bridge interfaces with OTP key."""
        value = (self.GetFeatures() >> 4) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('2047')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetUnused(self):
        """Reserved for future features."""
        value = (self.GetFeatures() >> 5) & 0x7ff
        return value
    
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetAction(self, value):
        """Specifies what action to take. For more details, see description for enum  textbf{FeatureLockType}."""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Auth_FeatureLock_SetGet.FeatureLockType.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Auth_FeatureLock_SetGet.MSG_OFFSET + 0, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('65535')
    @msg.offset('1')
    @msg.size('2')
    @msg.count(1)
    def SetFeatures(self, value):
        """Each bit in the array is mapped to a specific product feature.  If the bit is set, it means that the we will take the specifed action on the associated feature.  If the bit is clear, no action will be taken for that feature."""
        tmp = min(max(value, 0), 65535)
        struct.pack_into('>H', self.rawBuffer(), Auth_FeatureLock_SetGet.MSG_OFFSET + 1, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetTAP(self, value):
        """Lock or unlock the TAP feature."""
        tmp = min(max(value, 0), 1)
        self.SetFeatures((self.GetFeatures() & ~(0x1 << 0)) | ((tmp & 0x1) << 0))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetBMAPDebug(self, value):
        """Lock or unlock the BMAP Debug FBlocks."""
        tmp = min(max(value, 0), 1)
        self.SetFeatures((self.GetFeatures() & ~(0x1 << 1)) | ((tmp & 0x1) << 1))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetUSBDebug(self, value):
        """Enable or disable USBDBG enumeration."""
        tmp = min(max(value, 0), 1)
        self.SetFeatures((self.GetFeatures() & ~(0x1 << 2)) | ((tmp & 0x1) << 2))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetPersistentUnlockCommand(self, value):
        """Enable or disable the ability to persistently unlock a feature."""
        tmp = min(max(value, 0), 1)
        self.SetFeatures((self.GetFeatures() & ~(0x1 << 3)) | ((tmp & 0x1) << 3))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetSecureDebugTransports(self, value):
        """Secure (restrict) access to USBDBG and T-bridge interfaces with OTP key."""
        tmp = min(max(value, 0), 1)
        self.SetFeatures((self.GetFeatures() & ~(0x1 << 4)) | ((tmp & 0x1) << 4))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('2047')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetUnused(self, value):
        """Reserved for future features."""
        tmp = min(max(value, 0), 2047)
        self.SetFeatures((self.GetFeatures() & ~(0x7ff << 5)) | ((tmp & 0x7ff) << 5))
    

    # Reflection information
    fields = [ \
        FieldInfo(name="Action",type="enumeration",units="Enum",minVal="0",maxVal="255",description="Specifies what action to take. For more details, see description for enum  textbf{FeatureLockType}.",get=GetAction,set=SetAction,count=1, bitfieldInfo = [], enum = [FeatureLockType, ReverseFeatureLockType]),\
        FieldInfo(name="Features",type="int",units="",minVal="0",maxVal="65535",description="Each bit in the array is mapped to a specific product feature.  If the bit is set, it means that the we will take the specifed action on the associated feature.  If the bit is clear, no action will be taken for that feature.",get=GetFeatures,set=SetFeatures,count=1, bitfieldInfo = [\
            BitFieldInfo(name="TAP",type="int",units="",minVal="0",maxVal="1",description="Lock or unlock the TAP feature.",get=GetTAP,set=SetTAP, enum = []),\
            BitFieldInfo(name="BMAPDebug",type="int",units="",minVal="0",maxVal="1",description="Lock or unlock the BMAP Debug FBlocks.",get=GetBMAPDebug,set=SetBMAPDebug, enum = []),\
            BitFieldInfo(name="USBDebug",type="int",units="",minVal="0",maxVal="1",description="Enable or disable USBDBG enumeration.",get=GetUSBDebug,set=SetUSBDebug, enum = []),\
            BitFieldInfo(name="PersistentUnlockCommand",type="int",units="",minVal="0",maxVal="1",description="Enable or disable the ability to persistently unlock a feature.",get=GetPersistentUnlockCommand,set=SetPersistentUnlockCommand, enum = []),\
            BitFieldInfo(name="SecureDebugTransports",type="int",units="",minVal="0",maxVal="1",description="Secure (restrict) access to USBDBG and T-bridge interfaces with OTP key.",get=GetSecureDebugTransports,set=SetSecureDebugTransports, enum = []),\
            BitFieldInfo(name="Unused",type="int",units="",minVal="0",maxVal="2047",description="Reserved for future features.",get=GetUnused,set=SetUnused, enum = [])], enum = [])\
    ]

Messaging.Register("Auth.FeatureLock.SetGet", Auth_FeatureLock_SetGet.ID, Auth_FeatureLock_SetGet)
