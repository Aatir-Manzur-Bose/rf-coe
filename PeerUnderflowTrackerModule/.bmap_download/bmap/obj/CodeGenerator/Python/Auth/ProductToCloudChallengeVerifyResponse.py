#    obj/CodeGenerator/Python/Auth/ProductToCloudChallengeVerifyResponse.py
#    Created 27/07/2023 at 10:09:45 from:
#        Messages = messages/Auth/ProductToCloudChallengeVerifyResponse.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Auth_ProductToCloudChallengeVerifyResponse_Start :
    ID = 74181
    SIZE = 125
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    FeatureLockType = OrderedDict([("temporarily_unlocked", 0), ("temporarily_locked", 1), ("persistently_unlocked", 2), ("persistently_locked", 3)])
    ReverseFeatureLockType = OrderedDict([(0, "temporarily_unlocked"), (1, "temporarily_locked"), (2, "persistently_unlocked"), (3, "persistently_locked")])
    ChallengeReasonCode = OrderedDict([("feature_unlock", 1), ("grouping", 2)])
    ReverseChallengeReasonCode = OrderedDict([(1, "feature_unlock"), (2, "grouping")])
    IDs = OrderedDict([("FunctionBlock", 18), ("Function", 28), ("Operator", 5)])
    ReverseIDs = OrderedDict([(18, "FunctionBlock"), (28, "Function"), (5, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Auth_ProductToCloudChallengeVerifyResponse_Start.MSG_OFFSET + Auth_ProductToCloudChallengeVerifyResponse_Start.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Auth_ProductToCloudChallengeVerifyResponse_Start.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Auth_ProductToCloudChallengeVerifyResponse_Start.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Auth_ProductToCloudChallengeVerifyResponse_Start.MSG_OFFSET + Auth_ProductToCloudChallengeVerifyResponse_Start.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Auth_ProductToCloudChallengeVerifyResponse_Start.ID)
            self.hdr.SetDataLength(Auth_ProductToCloudChallengeVerifyResponse_Start.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Auth.ProductToCloudChallengeVerifyResponse.Start"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(16)
    def GetChallenge(self, idx):
        """Challenge nonce."""
        value = struct.unpack_from('B', self.rawBuffer(), Auth_ProductToCloudChallengeVerifyResponse_Start.MSG_OFFSET + 0+idx*1)[0]
        return value
    
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('16')
    @msg.size('1')
    @msg.count(1)
    def GetChallengeReason(self, enumAsInt=0):
        """Challenge reason, reason for product to cloud challenge"""
        value = struct.unpack_from('B', self.rawBuffer(), Auth_ProductToCloudChallengeVerifyResponse_Start.MSG_OFFSET + 16)[0]
        if not enumAsInt:
            value = Auth_ProductToCloudChallengeVerifyResponse_Start.ReverseChallengeReasonCode.get(value, value)
        return value
    
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('17')
    @msg.size('1')
    @msg.count(1)
    def GetAction(self, enumAsInt=0):
        """If  textbf{ChallengeReason} is  textbf{feature_unlock} Specifies what action to take. For more details, see description for enum  textbf{FeatureLockType}."""
        value = struct.unpack_from('B', self.rawBuffer(), Auth_ProductToCloudChallengeVerifyResponse_Start.MSG_OFFSET + 17)[0]
        if not enumAsInt:
            value = Auth_ProductToCloudChallengeVerifyResponse_Start.ReverseFeatureLockType.get(value, value)
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('65535')
    @msg.offset('18')
    @msg.size('2')
    @msg.count(1)
    def GetFeatures(self):
        """If  textbf{ChallengeReason} is  textbf{feature_unlock} Each bit in the array is mapped to a specific product feature.  If the bit is set, it means that the we will take the specifed action on the associated feature.  If the bit is clear, no action will be taken for that feature."""
        value = struct.unpack_from('>H', self.rawBuffer(), Auth_ProductToCloudChallengeVerifyResponse_Start.MSG_OFFSET + 18)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('18')
    @msg.size('0')
    @msg.count(1)
    def GetTAP(self):
        """Lock or unlock the TAP feature."""
        value = (self.GetFeatures() >> 0) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('18')
    @msg.size('0')
    @msg.count(1)
    def GetBMAPDebug(self):
        """Lock or unlock the BMAP Debug FBlocks."""
        value = (self.GetFeatures() >> 1) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('18')
    @msg.size('0')
    @msg.count(1)
    def GetUSBDebug(self):
        """Enable or disable USBDBG enumeration."""
        value = (self.GetFeatures() >> 2) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('18')
    @msg.size('0')
    @msg.count(1)
    def GetPersistentUnlockCommand(self):
        """Enable or disable the ability to persistently unlock a feature."""
        value = (self.GetFeatures() >> 3) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('18')
    @msg.size('0')
    @msg.count(1)
    def GetSecureDebugTransports(self):
        """Secure (restrict) access to USBDBG and T-bridge interfaces with OTP key."""
        value = (self.GetFeatures() >> 4) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('2047')
    @msg.offset('18')
    @msg.size('0')
    @msg.count(1)
    def GetUnused(self):
        """Reserved for future features."""
        value = (self.GetFeatures() >> 5) & 0x7ff
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('20')
    @msg.size('1')
    @msg.count(1)
    def GetSizeOfSignature(self):
        """Size of actual signature length"""
        value = struct.unpack_from('B', self.rawBuffer(), Auth_ProductToCloudChallengeVerifyResponse_Start.MSG_OFFSET + 20)[0]
        return value
    
    @msg.units('hex')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('21')
    @msg.size('1')
    @msg.count(104)
    def GetSignature(self, idx):
        """ECDSA signature length varies between 102 and 104 bytes. Signing is done using rotating key private key, whose public key is shared using RotatingPublicKey"""
        value = struct.unpack_from('B', self.rawBuffer(), Auth_ProductToCloudChallengeVerifyResponse_Start.MSG_OFFSET + 21+idx*1)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(16)
    def SetChallenge(self, value, idx):
        """Challenge nonce."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Auth_ProductToCloudChallengeVerifyResponse_Start.MSG_OFFSET + 0+idx*1, tmp)
    
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('16')
    @msg.size('1')
    @msg.count(1)
    def SetChallengeReason(self, value):
        """Challenge reason, reason for product to cloud challenge"""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Auth_ProductToCloudChallengeVerifyResponse_Start.ChallengeReasonCode.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Auth_ProductToCloudChallengeVerifyResponse_Start.MSG_OFFSET + 16, tmp)
    
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('17')
    @msg.size('1')
    @msg.count(1)
    def SetAction(self, value):
        """If  textbf{ChallengeReason} is  textbf{feature_unlock} Specifies what action to take. For more details, see description for enum  textbf{FeatureLockType}."""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Auth_ProductToCloudChallengeVerifyResponse_Start.FeatureLockType.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Auth_ProductToCloudChallengeVerifyResponse_Start.MSG_OFFSET + 17, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('65535')
    @msg.offset('18')
    @msg.size('2')
    @msg.count(1)
    def SetFeatures(self, value):
        """If  textbf{ChallengeReason} is  textbf{feature_unlock} Each bit in the array is mapped to a specific product feature.  If the bit is set, it means that the we will take the specifed action on the associated feature.  If the bit is clear, no action will be taken for that feature."""
        tmp = min(max(value, 0), 65535)
        struct.pack_into('>H', self.rawBuffer(), Auth_ProductToCloudChallengeVerifyResponse_Start.MSG_OFFSET + 18, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('18')
    @msg.size('0')
    @msg.count(1)
    def SetTAP(self, value):
        """Lock or unlock the TAP feature."""
        tmp = min(max(value, 0), 1)
        self.SetFeatures((self.GetFeatures() & ~(0x1 << 0)) | ((tmp & 0x1) << 0))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('18')
    @msg.size('0')
    @msg.count(1)
    def SetBMAPDebug(self, value):
        """Lock or unlock the BMAP Debug FBlocks."""
        tmp = min(max(value, 0), 1)
        self.SetFeatures((self.GetFeatures() & ~(0x1 << 1)) | ((tmp & 0x1) << 1))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('18')
    @msg.size('0')
    @msg.count(1)
    def SetUSBDebug(self, value):
        """Enable or disable USBDBG enumeration."""
        tmp = min(max(value, 0), 1)
        self.SetFeatures((self.GetFeatures() & ~(0x1 << 2)) | ((tmp & 0x1) << 2))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('18')
    @msg.size('0')
    @msg.count(1)
    def SetPersistentUnlockCommand(self, value):
        """Enable or disable the ability to persistently unlock a feature."""
        tmp = min(max(value, 0), 1)
        self.SetFeatures((self.GetFeatures() & ~(0x1 << 3)) | ((tmp & 0x1) << 3))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('18')
    @msg.size('0')
    @msg.count(1)
    def SetSecureDebugTransports(self, value):
        """Secure (restrict) access to USBDBG and T-bridge interfaces with OTP key."""
        tmp = min(max(value, 0), 1)
        self.SetFeatures((self.GetFeatures() & ~(0x1 << 4)) | ((tmp & 0x1) << 4))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('2047')
    @msg.offset('18')
    @msg.size('0')
    @msg.count(1)
    def SetUnused(self, value):
        """Reserved for future features."""
        tmp = min(max(value, 0), 2047)
        self.SetFeatures((self.GetFeatures() & ~(0x7ff << 5)) | ((tmp & 0x7ff) << 5))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('20')
    @msg.size('1')
    @msg.count(1)
    def SetSizeOfSignature(self, value):
        """Size of actual signature length"""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Auth_ProductToCloudChallengeVerifyResponse_Start.MSG_OFFSET + 20, tmp)
    
    @msg.units('hex')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('21')
    @msg.size('1')
    @msg.count(104)
    def SetSignature(self, value, idx):
        """ECDSA signature length varies between 102 and 104 bytes. Signing is done using rotating key private key, whose public key is shared using RotatingPublicKey"""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Auth_ProductToCloudChallengeVerifyResponse_Start.MSG_OFFSET + 21+idx*1, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="Challenge",type="int",units="",minVal="0",maxVal="255",description="Challenge nonce.",get=GetChallenge,set=SetChallenge,count=16, bitfieldInfo = [], enum = []),\
        FieldInfo(name="ChallengeReason",type="enumeration",units="Enum",minVal="0",maxVal="255",description="Challenge reason, reason for product to cloud challenge",get=GetChallengeReason,set=SetChallengeReason,count=1, bitfieldInfo = [], enum = [ChallengeReasonCode, ReverseChallengeReasonCode]),\
        FieldInfo(name="Action",type="enumeration",units="Enum",minVal="0",maxVal="255",description="If  textbf{ChallengeReason} is  textbf{feature_unlock} Specifies what action to take. For more details, see description for enum  textbf{FeatureLockType}.",get=GetAction,set=SetAction,count=1, bitfieldInfo = [], enum = [FeatureLockType, ReverseFeatureLockType]),\
        FieldInfo(name="Features",type="int",units="",minVal="0",maxVal="65535",description="If  textbf{ChallengeReason} is  textbf{feature_unlock} Each bit in the array is mapped to a specific product feature.  If the bit is set, it means that the we will take the specifed action on the associated feature.  If the bit is clear, no action will be taken for that feature.",get=GetFeatures,set=SetFeatures,count=1, bitfieldInfo = [\
            BitFieldInfo(name="TAP",type="int",units="",minVal="0",maxVal="1",description="Lock or unlock the TAP feature.",get=GetTAP,set=SetTAP, enum = []),\
            BitFieldInfo(name="BMAPDebug",type="int",units="",minVal="0",maxVal="1",description="Lock or unlock the BMAP Debug FBlocks.",get=GetBMAPDebug,set=SetBMAPDebug, enum = []),\
            BitFieldInfo(name="USBDebug",type="int",units="",minVal="0",maxVal="1",description="Enable or disable USBDBG enumeration.",get=GetUSBDebug,set=SetUSBDebug, enum = []),\
            BitFieldInfo(name="PersistentUnlockCommand",type="int",units="",minVal="0",maxVal="1",description="Enable or disable the ability to persistently unlock a feature.",get=GetPersistentUnlockCommand,set=SetPersistentUnlockCommand, enum = []),\
            BitFieldInfo(name="SecureDebugTransports",type="int",units="",minVal="0",maxVal="1",description="Secure (restrict) access to USBDBG and T-bridge interfaces with OTP key.",get=GetSecureDebugTransports,set=SetSecureDebugTransports, enum = []),\
            BitFieldInfo(name="Unused",type="int",units="",minVal="0",maxVal="2047",description="Reserved for future features.",get=GetUnused,set=SetUnused, enum = [])], enum = []),\
        FieldInfo(name="SizeOfSignature",type="int",units="",minVal="0",maxVal="255",description="Size of actual signature length",get=GetSizeOfSignature,set=SetSizeOfSignature,count=1, bitfieldInfo = [], enum = []),\
        FieldInfo(name="Signature",type="int",units="hex",minVal="0",maxVal="255",description="ECDSA signature length varies between 102 and 104 bytes. Signing is done using rotating key private key, whose public key is shared using RotatingPublicKey",get=GetSignature,set=SetSignature,count=104, bitfieldInfo = [], enum = [])\
    ]

Messaging.Register("Auth.ProductToCloudChallengeVerifyResponse.Start", Auth_ProductToCloudChallengeVerifyResponse_Start.ID, Auth_ProductToCloudChallengeVerifyResponse_Start)
#    obj/CodeGenerator/Python/Auth/ProductToCloudChallengeVerifyResponse.py
#    Created 27/07/2023 at 10:09:45 from:
#        Messages = messages/Auth/ProductToCloudChallengeVerifyResponse.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Auth_ProductToCloudChallengeVerifyResponse_Processing :
    ID = 74183
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 18), ("Function", 28), ("Operator", 7)])
    ReverseIDs = OrderedDict([(18, "FunctionBlock"), (28, "Function"), (7, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Auth_ProductToCloudChallengeVerifyResponse_Processing.MSG_OFFSET + Auth_ProductToCloudChallengeVerifyResponse_Processing.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Auth_ProductToCloudChallengeVerifyResponse_Processing.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Auth_ProductToCloudChallengeVerifyResponse_Processing.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Auth_ProductToCloudChallengeVerifyResponse_Processing.MSG_OFFSET + Auth_ProductToCloudChallengeVerifyResponse_Processing.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Auth_ProductToCloudChallengeVerifyResponse_Processing.ID)
            self.hdr.SetDataLength(Auth_ProductToCloudChallengeVerifyResponse_Processing.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Auth.ProductToCloudChallengeVerifyResponse.Processing"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("Auth.ProductToCloudChallengeVerifyResponse.Processing", Auth_ProductToCloudChallengeVerifyResponse_Processing.ID, Auth_ProductToCloudChallengeVerifyResponse_Processing)
#    obj/CodeGenerator/Python/Auth/ProductToCloudChallengeVerifyResponse.py
#    Created 27/07/2023 at 10:09:45 from:
#        Messages = messages/Auth/ProductToCloudChallengeVerifyResponse.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Auth_ProductToCloudChallengeVerifyResponse_Result :
    ID = 74182
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 18), ("Function", 28), ("Operator", 6)])
    ReverseIDs = OrderedDict([(18, "FunctionBlock"), (28, "Function"), (6, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Auth_ProductToCloudChallengeVerifyResponse_Result.MSG_OFFSET + Auth_ProductToCloudChallengeVerifyResponse_Result.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Auth_ProductToCloudChallengeVerifyResponse_Result.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Auth_ProductToCloudChallengeVerifyResponse_Result.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Auth_ProductToCloudChallengeVerifyResponse_Result.MSG_OFFSET + Auth_ProductToCloudChallengeVerifyResponse_Result.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Auth_ProductToCloudChallengeVerifyResponse_Result.ID)
            self.hdr.SetDataLength(Auth_ProductToCloudChallengeVerifyResponse_Result.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Auth.ProductToCloudChallengeVerifyResponse.Result"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("Auth.ProductToCloudChallengeVerifyResponse.Result", Auth_ProductToCloudChallengeVerifyResponse_Result.ID, Auth_ProductToCloudChallengeVerifyResponse_Result)
#    obj/CodeGenerator/Python/Auth/ProductToCloudChallengeVerifyResponse.py
#    Created 27/07/2023 at 10:09:45 from:
#        Messages = messages/Auth/ProductToCloudChallengeVerifyResponse.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Auth_ProductToCloudChallengeVerifyResponse_Error :
    ID = 74180
    SIZE = 1
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    ErrorResponseCodes = OrderedDict([("Length", 1), ("Checksum", 2), ("FBlockNotSupported", 3), ("FunctionNotSupported", 4), ("OperatorNotSupported", 5), ("InvalidData", 6), ("DataNotAvailable", 7), ("RunTime", 8), ("Timeout", 9), ("InvalidState", 10), ("DeviceNotFound", 11), ("Busy", 12), ("UnableToConnectTimeout", 13), ("UnableToConnectSourceDeviceKeyMissing", 14), ("OTAFirmwareUpdateInProgress", 15), ("LowBatteryVoltage", 16), ("ChargerNotConnected", 17), ("UpdateNotAllowed", 18), ("UnknownPortNumber", 19), ("InsecureTransport", 20), ("InvalidOTPKey", 21), ("OutOfMemory", 22), ("CryptoProcessingError", 23), ("FeatureLocked", 24), ("FunctionBlockSpecificErrorCode", 255)])
    ReverseErrorResponseCodes = OrderedDict([(1, "Length"), (2, "Checksum"), (3, "FBlockNotSupported"), (4, "FunctionNotSupported"), (5, "OperatorNotSupported"), (6, "InvalidData"), (7, "DataNotAvailable"), (8, "RunTime"), (9, "Timeout"), (10, "InvalidState"), (11, "DeviceNotFound"), (12, "Busy"), (13, "UnableToConnectTimeout"), (14, "UnableToConnectSourceDeviceKeyMissing"), (15, "OTAFirmwareUpdateInProgress"), (16, "LowBatteryVoltage"), (17, "ChargerNotConnected"), (18, "UpdateNotAllowed"), (19, "UnknownPortNumber"), (20, "InsecureTransport"), (21, "InvalidOTPKey"), (22, "OutOfMemory"), (23, "CryptoProcessingError"), (24, "FeatureLocked"), (255, "FunctionBlockSpecificErrorCode")])
    IDs = OrderedDict([("FunctionBlock", 18), ("Function", 28), ("Operator", 4)])
    ReverseIDs = OrderedDict([(18, "FunctionBlock"), (28, "Function"), (4, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Auth_ProductToCloudChallengeVerifyResponse_Error.MSG_OFFSET + Auth_ProductToCloudChallengeVerifyResponse_Error.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Auth_ProductToCloudChallengeVerifyResponse_Error.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Auth_ProductToCloudChallengeVerifyResponse_Error.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Auth_ProductToCloudChallengeVerifyResponse_Error.MSG_OFFSET + Auth_ProductToCloudChallengeVerifyResponse_Error.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Auth_ProductToCloudChallengeVerifyResponse_Error.ID)
            self.hdr.SetDataLength(Auth_ProductToCloudChallengeVerifyResponse_Error.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Auth.ProductToCloudChallengeVerifyResponse.Error"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetErrorCodes(self, enumAsInt=0):
        """"""
        value = struct.unpack_from('B', self.rawBuffer(), Auth_ProductToCloudChallengeVerifyResponse_Error.MSG_OFFSET + 0)[0]
        if not enumAsInt:
            value = Auth_ProductToCloudChallengeVerifyResponse_Error.ReverseErrorResponseCodes.get(value, value)
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetErrorCodes(self, value):
        """"""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Auth_ProductToCloudChallengeVerifyResponse_Error.ErrorResponseCodes.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Auth_ProductToCloudChallengeVerifyResponse_Error.MSG_OFFSET + 0, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="ErrorCodes",type="enumeration",units="",minVal="0",maxVal="255",description="",get=GetErrorCodes,set=SetErrorCodes,count=1, bitfieldInfo = [], enum = [ErrorResponseCodes, ReverseErrorResponseCodes])\
    ]

Messaging.Register("Auth.ProductToCloudChallengeVerifyResponse.Error", Auth_ProductToCloudChallengeVerifyResponse_Error.ID, Auth_ProductToCloudChallengeVerifyResponse_Error)
