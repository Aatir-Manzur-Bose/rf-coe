#    obj/CodeGenerator/Python/DeviceManagement/PrepareP2P.py
#    Created 27/07/2023 at 10:10:24 from:
#        Messages = messages/DeviceManagement/PrepareP2P.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class DeviceManagement_PrepareP2P_Start :
    ID = 16549
    SIZE = 13
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 4), ("Function", 10), ("Operator", 5)])
    ReverseIDs = OrderedDict([(4, "FunctionBlock"), (10, "Function"), (5, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(DeviceManagement_PrepareP2P_Start.MSG_OFFSET + DeviceManagement_PrepareP2P_Start.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, DeviceManagement_PrepareP2P_Start.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, DeviceManagement_PrepareP2P_Start.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(DeviceManagement_PrepareP2P_Start.MSG_OFFSET + DeviceManagement_PrepareP2P_Start.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(DeviceManagement_PrepareP2P_Start.ID)
            self.hdr.SetDataLength(DeviceManagement_PrepareP2P_Start.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "DeviceManagement.PrepareP2P.Start"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetConnectionType(self):
        """"""
        value = struct.unpack_from('B', self.rawBuffer(), DeviceManagement_PrepareP2P_Start.MSG_OFFSET + 0)[0]
        return value
    
    @msg.units('P2PMode')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('63')
    @msg.offset('0')
    @msg.size('0')
    @msg.count(1)
    def GetP2PMode(self):
        """P2PMode"""
        value = (self.GetConnectionType() >> 0) & 0x3f
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('0')
    @msg.size('0')
    @msg.count(1)
    def GetProductType(self):
        """0 == personal listening device, 1 == out loud listening device"""
        value = (self.GetConnectionType() >> 6) & 0x1
        return value
    
    @msg.units('hex')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('1')
    @msg.size('1')
    @msg.count(6)
    def GetMACAddress(self, idx):
        """MAC address of P2P master"""
        value = struct.unpack_from('B', self.rawBuffer(), DeviceManagement_PrepareP2P_Start.MSG_OFFSET + 1+idx*1)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('65535')
    @msg.offset('7')
    @msg.size('2')
    @msg.count(1)
    def GetPIDP2PMaster(self):
        """PID of P2P master (MSB first)"""
        value = struct.unpack_from('>H', self.rawBuffer(), DeviceManagement_PrepareP2P_Start.MSG_OFFSET + 7)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('9')
    @msg.size('1')
    @msg.count(1)
    def GetVariantIDP2PMaster(self):
        """Variant ID of P2P master"""
        value = struct.unpack_from('B', self.rawBuffer(), DeviceManagement_PrepareP2P_Start.MSG_OFFSET + 9)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('10')
    @msg.size('1')
    @msg.count(1)
    def GetSupportedConnectionTypes(self):
        """"""
        value = struct.unpack_from('B', self.rawBuffer(), DeviceManagement_PrepareP2P_Start.MSG_OFFSET + 10)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('7')
    @msg.offset('10')
    @msg.size('0')
    @msg.count(1)
    def GetUnusedBits(self):
        """First 3 bits unused"""
        value = (self.GetSupportedConnectionTypes() >> 0) & 0x7
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('10')
    @msg.size('0')
    @msg.count(1)
    def GetVoiceP2PConnectionOppositeTypeSupported(self):
        """Voice P2P connection supported for product of opposite type"""
        value = (self.GetSupportedConnectionTypes() >> 3) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('10')
    @msg.size('0')
    @msg.count(1)
    def GetVoiceP2PConnectionSameTypeSupported(self):
        """Voice P2P connection supported for product of same type"""
        value = (self.GetSupportedConnectionTypes() >> 4) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('10')
    @msg.size('0')
    @msg.count(1)
    def GetMusicP2PConnectionIdenticalPIDOnlySupported(self):
        """Music P2P connection only support for product with identical PID"""
        value = (self.GetSupportedConnectionTypes() >> 5) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('10')
    @msg.size('0')
    @msg.count(1)
    def GetMusicP2PConnectionSameTypeSupported(self):
        """Music P2P connection supported for product of same type"""
        value = (self.GetSupportedConnectionTypes() >> 6) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('10')
    @msg.size('0')
    @msg.count(1)
    def GetProductTypeSupported(self):
        """0 == personal listening device, 1 == out loud listening device"""
        value = (self.GetSupportedConnectionTypes() >> 7) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('11')
    @msg.size('1')
    @msg.count(1)
    def GetCompatibilityNumberP2PMaster(self):
        """Compatibility number of P2P master"""
        value = struct.unpack_from('B', self.rawBuffer(), DeviceManagement_PrepareP2P_Start.MSG_OFFSET + 11)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('12')
    @msg.size('1')
    @msg.count(1)
    def GetCodec(self):
        """0 == SBC A2DP codec, 1 == AAC A2DP codec"""
        value = struct.unpack_from('B', self.rawBuffer(), DeviceManagement_PrepareP2P_Start.MSG_OFFSET + 12)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetConnectionType(self, value):
        """"""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), DeviceManagement_PrepareP2P_Start.MSG_OFFSET + 0, tmp)
    
    @msg.units('P2PMode')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('63')
    @msg.offset('0')
    @msg.size('0')
    @msg.count(1)
    def SetP2PMode(self, value):
        """P2PMode"""
        tmp = min(max(value, 0), 63)
        self.SetConnectionType((self.GetConnectionType() & ~(0x3f << 0)) | ((tmp & 0x3f) << 0))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('0')
    @msg.size('0')
    @msg.count(1)
    def SetProductType(self, value):
        """0 == personal listening device, 1 == out loud listening device"""
        tmp = min(max(value, 0), 1)
        self.SetConnectionType((self.GetConnectionType() & ~(0x1 << 6)) | ((tmp & 0x1) << 6))
    
    @msg.units('hex')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('1')
    @msg.size('1')
    @msg.count(6)
    def SetMACAddress(self, value, idx):
        """MAC address of P2P master"""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), DeviceManagement_PrepareP2P_Start.MSG_OFFSET + 1+idx*1, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('65535')
    @msg.offset('7')
    @msg.size('2')
    @msg.count(1)
    def SetPIDP2PMaster(self, value):
        """PID of P2P master (MSB first)"""
        tmp = min(max(value, 0), 65535)
        struct.pack_into('>H', self.rawBuffer(), DeviceManagement_PrepareP2P_Start.MSG_OFFSET + 7, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('9')
    @msg.size('1')
    @msg.count(1)
    def SetVariantIDP2PMaster(self, value):
        """Variant ID of P2P master"""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), DeviceManagement_PrepareP2P_Start.MSG_OFFSET + 9, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('10')
    @msg.size('1')
    @msg.count(1)
    def SetSupportedConnectionTypes(self, value):
        """"""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), DeviceManagement_PrepareP2P_Start.MSG_OFFSET + 10, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('7')
    @msg.offset('10')
    @msg.size('0')
    @msg.count(1)
    def SetUnusedBits(self, value):
        """First 3 bits unused"""
        tmp = min(max(value, 0), 7)
        self.SetSupportedConnectionTypes((self.GetSupportedConnectionTypes() & ~(0x7 << 0)) | ((tmp & 0x7) << 0))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('10')
    @msg.size('0')
    @msg.count(1)
    def SetVoiceP2PConnectionOppositeTypeSupported(self, value):
        """Voice P2P connection supported for product of opposite type"""
        tmp = min(max(value, 0), 1)
        self.SetSupportedConnectionTypes((self.GetSupportedConnectionTypes() & ~(0x1 << 3)) | ((tmp & 0x1) << 3))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('10')
    @msg.size('0')
    @msg.count(1)
    def SetVoiceP2PConnectionSameTypeSupported(self, value):
        """Voice P2P connection supported for product of same type"""
        tmp = min(max(value, 0), 1)
        self.SetSupportedConnectionTypes((self.GetSupportedConnectionTypes() & ~(0x1 << 4)) | ((tmp & 0x1) << 4))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('10')
    @msg.size('0')
    @msg.count(1)
    def SetMusicP2PConnectionIdenticalPIDOnlySupported(self, value):
        """Music P2P connection only support for product with identical PID"""
        tmp = min(max(value, 0), 1)
        self.SetSupportedConnectionTypes((self.GetSupportedConnectionTypes() & ~(0x1 << 5)) | ((tmp & 0x1) << 5))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('10')
    @msg.size('0')
    @msg.count(1)
    def SetMusicP2PConnectionSameTypeSupported(self, value):
        """Music P2P connection supported for product of same type"""
        tmp = min(max(value, 0), 1)
        self.SetSupportedConnectionTypes((self.GetSupportedConnectionTypes() & ~(0x1 << 6)) | ((tmp & 0x1) << 6))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('10')
    @msg.size('0')
    @msg.count(1)
    def SetProductTypeSupported(self, value):
        """0 == personal listening device, 1 == out loud listening device"""
        tmp = min(max(value, 0), 1)
        self.SetSupportedConnectionTypes((self.GetSupportedConnectionTypes() & ~(0x1 << 7)) | ((tmp & 0x1) << 7))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('11')
    @msg.size('1')
    @msg.count(1)
    def SetCompatibilityNumberP2PMaster(self, value):
        """Compatibility number of P2P master"""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), DeviceManagement_PrepareP2P_Start.MSG_OFFSET + 11, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('12')
    @msg.size('1')
    @msg.count(1)
    def SetCodec(self, value):
        """0 == SBC A2DP codec, 1 == AAC A2DP codec"""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), DeviceManagement_PrepareP2P_Start.MSG_OFFSET + 12, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="ConnectionType",type="int",units="",minVal="0",maxVal="255",description="",get=GetConnectionType,set=SetConnectionType,count=1, bitfieldInfo = [\
            BitFieldInfo(name="P2PMode",type="int",units="P2PMode",minVal="0",maxVal="63",description="P2PMode",get=GetP2PMode,set=SetP2PMode, enum = []),\
            BitFieldInfo(name="ProductType",type="int",units="",minVal="0",maxVal="1",description="0 == personal listening device, 1 == out loud listening device",get=GetProductType,set=SetProductType, enum = [])], enum = []),\
        FieldInfo(name="MACAddress",type="int",units="hex",minVal="0",maxVal="255",description="MAC address of P2P master",get=GetMACAddress,set=SetMACAddress,count=6, bitfieldInfo = [], enum = []),\
        FieldInfo(name="PIDP2PMaster",type="int",units="",minVal="0",maxVal="65535",description="PID of P2P master (MSB first)",get=GetPIDP2PMaster,set=SetPIDP2PMaster,count=1, bitfieldInfo = [], enum = []),\
        FieldInfo(name="VariantIDP2PMaster",type="int",units="",minVal="0",maxVal="255",description="Variant ID of P2P master",get=GetVariantIDP2PMaster,set=SetVariantIDP2PMaster,count=1, bitfieldInfo = [], enum = []),\
        FieldInfo(name="SupportedConnectionTypes",type="int",units="",minVal="0",maxVal="255",description="",get=GetSupportedConnectionTypes,set=SetSupportedConnectionTypes,count=1, bitfieldInfo = [\
            BitFieldInfo(name="UnusedBits",type="int",units="",minVal="0",maxVal="7",description="First 3 bits unused",get=GetUnusedBits,set=SetUnusedBits, enum = []),\
            BitFieldInfo(name="VoiceP2PConnectionOppositeTypeSupported",type="int",units="",minVal="0",maxVal="1",description="Voice P2P connection supported for product of opposite type",get=GetVoiceP2PConnectionOppositeTypeSupported,set=SetVoiceP2PConnectionOppositeTypeSupported, enum = []),\
            BitFieldInfo(name="VoiceP2PConnectionSameTypeSupported",type="int",units="",minVal="0",maxVal="1",description="Voice P2P connection supported for product of same type",get=GetVoiceP2PConnectionSameTypeSupported,set=SetVoiceP2PConnectionSameTypeSupported, enum = []),\
            BitFieldInfo(name="MusicP2PConnectionIdenticalPIDOnlySupported",type="int",units="",minVal="0",maxVal="1",description="Music P2P connection only support for product with identical PID",get=GetMusicP2PConnectionIdenticalPIDOnlySupported,set=SetMusicP2PConnectionIdenticalPIDOnlySupported, enum = []),\
            BitFieldInfo(name="MusicP2PConnectionSameTypeSupported",type="int",units="",minVal="0",maxVal="1",description="Music P2P connection supported for product of same type",get=GetMusicP2PConnectionSameTypeSupported,set=SetMusicP2PConnectionSameTypeSupported, enum = []),\
            BitFieldInfo(name="ProductTypeSupported",type="int",units="",minVal="0",maxVal="1",description="0 == personal listening device, 1 == out loud listening device",get=GetProductTypeSupported,set=SetProductTypeSupported, enum = [])], enum = []),\
        FieldInfo(name="CompatibilityNumberP2PMaster",type="int",units="",minVal="0",maxVal="255",description="Compatibility number of P2P master",get=GetCompatibilityNumberP2PMaster,set=SetCompatibilityNumberP2PMaster,count=1, bitfieldInfo = [], enum = []),\
        FieldInfo(name="Codec",type="int",units="",minVal="0",maxVal="255",description="0 == SBC A2DP codec, 1 == AAC A2DP codec",get=GetCodec,set=SetCodec,count=1, bitfieldInfo = [], enum = [])\
    ]

Messaging.Register("DeviceManagement.PrepareP2P.Start", DeviceManagement_PrepareP2P_Start.ID, DeviceManagement_PrepareP2P_Start)
#    obj/CodeGenerator/Python/DeviceManagement/PrepareP2P.py
#    Created 27/07/2023 at 10:10:24 from:
#        Messages = messages/DeviceManagement/PrepareP2P.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class DeviceManagement_PrepareP2P_Processing :
    ID = 16551
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 4), ("Function", 10), ("Operator", 7)])
    ReverseIDs = OrderedDict([(4, "FunctionBlock"), (10, "Function"), (7, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(DeviceManagement_PrepareP2P_Processing.MSG_OFFSET + DeviceManagement_PrepareP2P_Processing.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, DeviceManagement_PrepareP2P_Processing.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, DeviceManagement_PrepareP2P_Processing.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(DeviceManagement_PrepareP2P_Processing.MSG_OFFSET + DeviceManagement_PrepareP2P_Processing.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(DeviceManagement_PrepareP2P_Processing.ID)
            self.hdr.SetDataLength(DeviceManagement_PrepareP2P_Processing.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "DeviceManagement.PrepareP2P.Processing"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("DeviceManagement.PrepareP2P.Processing", DeviceManagement_PrepareP2P_Processing.ID, DeviceManagement_PrepareP2P_Processing)
#    obj/CodeGenerator/Python/DeviceManagement/PrepareP2P.py
#    Created 27/07/2023 at 10:10:24 from:
#        Messages = messages/DeviceManagement/PrepareP2P.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class DeviceManagement_PrepareP2P_Result :
    ID = 16550
    SIZE = 2
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 4), ("Function", 10), ("Operator", 6)])
    ReverseIDs = OrderedDict([(4, "FunctionBlock"), (10, "Function"), (6, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(DeviceManagement_PrepareP2P_Result.MSG_OFFSET + DeviceManagement_PrepareP2P_Result.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, DeviceManagement_PrepareP2P_Result.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, DeviceManagement_PrepareP2P_Result.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(DeviceManagement_PrepareP2P_Result.MSG_OFFSET + DeviceManagement_PrepareP2P_Result.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(DeviceManagement_PrepareP2P_Result.ID)
            self.hdr.SetDataLength(DeviceManagement_PrepareP2P_Result.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "DeviceManagement.PrepareP2P.Result"
    # Accessors
    @msg.units('Milliseconds')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('65535')
    @msg.offset('0')
    @msg.size('2')
    @msg.count(1)
    def GetAudioLatency(self):
        """Audio latency for product returned to allow P2P master to time align audio streams (16-bit, MFB first, in milliseconds)"""
        value = struct.unpack_from('>H', self.rawBuffer(), DeviceManagement_PrepareP2P_Result.MSG_OFFSET + 0)[0]
        return value
    
    @msg.units('Milliseconds')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('65535')
    @msg.offset('0')
    @msg.size('2')
    @msg.count(1)
    def SetAudioLatency(self, value):
        """Audio latency for product returned to allow P2P master to time align audio streams (16-bit, MFB first, in milliseconds)"""
        tmp = min(max(value, 0), 65535)
        struct.pack_into('>H', self.rawBuffer(), DeviceManagement_PrepareP2P_Result.MSG_OFFSET + 0, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="AudioLatency",type="int",units="Milliseconds",minVal="0",maxVal="65535",description="Audio latency for product returned to allow P2P master to time align audio streams (16-bit, MFB first, in milliseconds)",get=GetAudioLatency,set=SetAudioLatency,count=1, bitfieldInfo = [], enum = [])\
    ]

Messaging.Register("DeviceManagement.PrepareP2P.Result", DeviceManagement_PrepareP2P_Result.ID, DeviceManagement_PrepareP2P_Result)
