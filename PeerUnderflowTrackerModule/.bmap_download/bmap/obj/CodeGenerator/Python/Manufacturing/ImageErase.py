#    obj/CodeGenerator/Python/Manufacturing/ImageErase.py
#    Created 27/07/2023 at 10:10:52 from:
#        Messages = messages/Manufacturing/ImageErase.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Manufacturing_ImageErase_Start :
    ID = 94661
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 23), ("Function", 28), ("Operator", 5)])
    ReverseIDs = OrderedDict([(23, "FunctionBlock"), (28, "Function"), (5, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Manufacturing_ImageErase_Start.MSG_OFFSET + Manufacturing_ImageErase_Start.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Manufacturing_ImageErase_Start.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Manufacturing_ImageErase_Start.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Manufacturing_ImageErase_Start.MSG_OFFSET + Manufacturing_ImageErase_Start.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Manufacturing_ImageErase_Start.ID)
            self.hdr.SetDataLength(Manufacturing_ImageErase_Start.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Manufacturing.ImageErase.Start"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("Manufacturing.ImageErase.Start", Manufacturing_ImageErase_Start.ID, Manufacturing_ImageErase_Start)
#    obj/CodeGenerator/Python/Manufacturing/ImageErase.py
#    Created 27/07/2023 at 10:10:52 from:
#        Messages = messages/Manufacturing/ImageErase.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Manufacturing_ImageErase_Processing :
    ID = 94663
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 23), ("Function", 28), ("Operator", 7)])
    ReverseIDs = OrderedDict([(23, "FunctionBlock"), (28, "Function"), (7, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Manufacturing_ImageErase_Processing.MSG_OFFSET + Manufacturing_ImageErase_Processing.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Manufacturing_ImageErase_Processing.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Manufacturing_ImageErase_Processing.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Manufacturing_ImageErase_Processing.MSG_OFFSET + Manufacturing_ImageErase_Processing.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Manufacturing_ImageErase_Processing.ID)
            self.hdr.SetDataLength(Manufacturing_ImageErase_Processing.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Manufacturing.ImageErase.Processing"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("Manufacturing.ImageErase.Processing", Manufacturing_ImageErase_Processing.ID, Manufacturing_ImageErase_Processing)
#    obj/CodeGenerator/Python/Manufacturing/ImageErase.py
#    Created 27/07/2023 at 10:10:52 from:
#        Messages = messages/Manufacturing/ImageErase.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Manufacturing_ImageErase_Result :
    ID = 94662
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 23), ("Function", 28), ("Operator", 6)])
    ReverseIDs = OrderedDict([(23, "FunctionBlock"), (28, "Function"), (6, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Manufacturing_ImageErase_Result.MSG_OFFSET + Manufacturing_ImageErase_Result.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Manufacturing_ImageErase_Result.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Manufacturing_ImageErase_Result.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Manufacturing_ImageErase_Result.MSG_OFFSET + Manufacturing_ImageErase_Result.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Manufacturing_ImageErase_Result.ID)
            self.hdr.SetDataLength(Manufacturing_ImageErase_Result.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Manufacturing.ImageErase.Result"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("Manufacturing.ImageErase.Result", Manufacturing_ImageErase_Result.ID, Manufacturing_ImageErase_Result)
#    obj/CodeGenerator/Python/Manufacturing/ImageErase.py
#    Created 27/07/2023 at 10:10:52 from:
#        Messages = messages/Manufacturing/ImageErase.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Manufacturing_ImageErase_Error :
    ID = 94660
    SIZE = 2
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    ManufacturingErrorResponseCodes = OrderedDict([("Capability Not Loaded", 0), ("Capability Already loaded", 1), ("Image copy Error", 2), ("Image swap or switch Error", 3), ("Image commit Error", 4), ("Image erase Error", 5), ("Erase Inactive Bank Image Error", 6), ("Erase Inactive Bank Image Timeout", 7)])
    ReverseManufacturingErrorResponseCodes = OrderedDict([(0, "Capability Not Loaded"), (1, "Capability Already loaded"), (2, "Image copy Error"), (3, "Image swap or switch Error"), (4, "Image commit Error"), (5, "Image erase Error"), (6, "Erase Inactive Bank Image Error"), (7, "Erase Inactive Bank Image Timeout")])
    ErrorResponseCodes = OrderedDict([("Length", 1), ("Checksum", 2), ("FBlockNotSupported", 3), ("FunctionNotSupported", 4), ("OperatorNotSupported", 5), ("InvalidData", 6), ("DataNotAvailable", 7), ("RunTime", 8), ("Timeout", 9), ("InvalidState", 10), ("DeviceNotFound", 11), ("Busy", 12), ("UnableToConnectTimeout", 13), ("UnableToConnectSourceDeviceKeyMissing", 14), ("OTAFirmwareUpdateInProgress", 15), ("LowBatteryVoltage", 16), ("ChargerNotConnected", 17), ("UpdateNotAllowed", 18), ("UnknownPortNumber", 19), ("InsecureTransport", 20), ("InvalidOTPKey", 21), ("OutOfMemory", 22), ("CryptoProcessingError", 23), ("FeatureLocked", 24), ("FunctionBlockSpecificErrorCode", 255)])
    ReverseErrorResponseCodes = OrderedDict([(1, "Length"), (2, "Checksum"), (3, "FBlockNotSupported"), (4, "FunctionNotSupported"), (5, "OperatorNotSupported"), (6, "InvalidData"), (7, "DataNotAvailable"), (8, "RunTime"), (9, "Timeout"), (10, "InvalidState"), (11, "DeviceNotFound"), (12, "Busy"), (13, "UnableToConnectTimeout"), (14, "UnableToConnectSourceDeviceKeyMissing"), (15, "OTAFirmwareUpdateInProgress"), (16, "LowBatteryVoltage"), (17, "ChargerNotConnected"), (18, "UpdateNotAllowed"), (19, "UnknownPortNumber"), (20, "InsecureTransport"), (21, "InvalidOTPKey"), (22, "OutOfMemory"), (23, "CryptoProcessingError"), (24, "FeatureLocked"), (255, "FunctionBlockSpecificErrorCode")])
    IDs = OrderedDict([("FunctionBlock", 23), ("Function", 28), ("Operator", 4)])
    ReverseIDs = OrderedDict([(23, "FunctionBlock"), (28, "Function"), (4, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Manufacturing_ImageErase_Error.MSG_OFFSET + Manufacturing_ImageErase_Error.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Manufacturing_ImageErase_Error.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Manufacturing_ImageErase_Error.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Manufacturing_ImageErase_Error.MSG_OFFSET + Manufacturing_ImageErase_Error.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Manufacturing_ImageErase_Error.ID)
            self.hdr.SetDataLength(Manufacturing_ImageErase_Error.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Manufacturing.ImageErase.Error"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetErrorCode(self, enumAsInt=0):
        """Generic BMAP error."""
        value = struct.unpack_from('B', self.rawBuffer(), Manufacturing_ImageErase_Error.MSG_OFFSET + 0)[0]
        if not enumAsInt:
            value = Manufacturing_ImageErase_Error.ReverseErrorResponseCodes.get(value, value)
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('1')
    @msg.size('1')
    @msg.count(1)
    def GetFblockSpecificErrorCode(self, enumAsInt=0):
        """Function block specific error."""
        value = struct.unpack_from('B', self.rawBuffer(), Manufacturing_ImageErase_Error.MSG_OFFSET + 1)[0]
        if not enumAsInt:
            value = Manufacturing_ImageErase_Error.ReverseManufacturingErrorResponseCodes.get(value, value)
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetErrorCode(self, value):
        """Generic BMAP error."""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Manufacturing_ImageErase_Error.ErrorResponseCodes.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Manufacturing_ImageErase_Error.MSG_OFFSET + 0, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('1')
    @msg.size('1')
    @msg.count(1)
    def SetFblockSpecificErrorCode(self, value):
        """Function block specific error."""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Manufacturing_ImageErase_Error.ManufacturingErrorResponseCodes.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Manufacturing_ImageErase_Error.MSG_OFFSET + 1, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="ErrorCode",type="enumeration",units="",minVal="0",maxVal="255",description="Generic BMAP error.",get=GetErrorCode,set=SetErrorCode,count=1, bitfieldInfo = [], enum = [ErrorResponseCodes, ReverseErrorResponseCodes]),\
        FieldInfo(name="FblockSpecificErrorCode",type="enumeration",units="",minVal="0",maxVal="255",description="Function block specific error.",get=GetFblockSpecificErrorCode,set=SetFblockSpecificErrorCode,count=1, bitfieldInfo = [], enum = [ManufacturingErrorResponseCodes, ReverseManufacturingErrorResponseCodes])\
    ]

Messaging.Register("Manufacturing.ImageErase.Error", Manufacturing_ImageErase_Error.ID, Manufacturing_ImageErase_Error)
