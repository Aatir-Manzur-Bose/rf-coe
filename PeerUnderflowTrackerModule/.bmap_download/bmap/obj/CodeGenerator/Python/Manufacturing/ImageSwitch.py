#    obj/CodeGenerator/Python/Manufacturing/ImageSwitch.py
#    Created 27/07/2023 at 10:10:53 from:
#        Messages = messages/Manufacturing/ImageSwitch.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Manufacturing_ImageSwitch_Start :
    ID = 94469
    SIZE = 3
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    SwitchModes = OrderedDict([("FlipSwitch", 0), ("TargetSwitch", 1)])
    ReverseSwitchModes = OrderedDict([(0, "FlipSwitch"), (1, "TargetSwitch")])
    Persistence = OrderedDict([("Persistent", 0), ("NotPersistent", 1)])
    ReversePersistence = OrderedDict([(0, "Persistent"), (1, "NotPersistent")])
    IDs = OrderedDict([("FunctionBlock", 23), ("Function", 16), ("Operator", 5)])
    ReverseIDs = OrderedDict([(23, "FunctionBlock"), (16, "Function"), (5, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Manufacturing_ImageSwitch_Start.MSG_OFFSET + Manufacturing_ImageSwitch_Start.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Manufacturing_ImageSwitch_Start.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Manufacturing_ImageSwitch_Start.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Manufacturing_ImageSwitch_Start.MSG_OFFSET + Manufacturing_ImageSwitch_Start.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Manufacturing_ImageSwitch_Start.ID)
            self.hdr.SetDataLength(Manufacturing_ImageSwitch_Start.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Manufacturing.ImageSwitch.Start"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetPersistence(self, enumAsInt=0):
        """Persistence: Will the new image be committed"""
        value = struct.unpack_from('B', self.rawBuffer(), Manufacturing_ImageSwitch_Start.MSG_OFFSET + 0)[0]
        if not enumAsInt:
            value = Manufacturing_ImageSwitch_Start.ReversePersistence.get(value, value)
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('1')
    @msg.size('1')
    @msg.count(1)
    def GetSwitchMode(self, enumAsInt=0):
        """SwitchMode: Mode of switching images"""
        value = struct.unpack_from('B', self.rawBuffer(), Manufacturing_ImageSwitch_Start.MSG_OFFSET + 1)[0]
        if not enumAsInt:
            value = Manufacturing_ImageSwitch_Start.ReverseSwitchModes.get(value, value)
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('2')
    @msg.size('1')
    @msg.count(1)
    def GetTargetImage(self):
        """TargetImage (optional): If SwitchMode is set to TargetSwitch, this variable provides the target image to switch to. For example: 0x0 if image in bank0, 0x1 if image in bank1."""
        value = struct.unpack_from('B', self.rawBuffer(), Manufacturing_ImageSwitch_Start.MSG_OFFSET + 2)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetPersistence(self, value):
        """Persistence: Will the new image be committed"""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Manufacturing_ImageSwitch_Start.Persistence.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Manufacturing_ImageSwitch_Start.MSG_OFFSET + 0, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('1')
    @msg.size('1')
    @msg.count(1)
    def SetSwitchMode(self, value):
        """SwitchMode: Mode of switching images"""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Manufacturing_ImageSwitch_Start.SwitchModes.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Manufacturing_ImageSwitch_Start.MSG_OFFSET + 1, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('2')
    @msg.size('1')
    @msg.count(1)
    def SetTargetImage(self, value):
        """TargetImage (optional): If SwitchMode is set to TargetSwitch, this variable provides the target image to switch to. For example: 0x0 if image in bank0, 0x1 if image in bank1."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Manufacturing_ImageSwitch_Start.MSG_OFFSET + 2, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="Persistence",type="enumeration",units="",minVal="0",maxVal="255",description="Persistence: Will the new image be committed",get=GetPersistence,set=SetPersistence,count=1, bitfieldInfo = [], enum = [Persistence, ReversePersistence]),\
        FieldInfo(name="SwitchMode",type="enumeration",units="",minVal="0",maxVal="255",description="SwitchMode: Mode of switching images",get=GetSwitchMode,set=SetSwitchMode,count=1, bitfieldInfo = [], enum = [SwitchModes, ReverseSwitchModes]),\
        FieldInfo(name="TargetImage",type="int",units="",minVal="0",maxVal="255",description="TargetImage (optional): If SwitchMode is set to TargetSwitch, this variable provides the target image to switch to. For example: 0x0 if image in bank0, 0x1 if image in bank1.",get=GetTargetImage,set=SetTargetImage,count=1, bitfieldInfo = [], enum = [])\
    ]

Messaging.Register("Manufacturing.ImageSwitch.Start", Manufacturing_ImageSwitch_Start.ID, Manufacturing_ImageSwitch_Start)
#    obj/CodeGenerator/Python/Manufacturing/ImageSwitch.py
#    Created 27/07/2023 at 10:10:53 from:
#        Messages = messages/Manufacturing/ImageSwitch.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Manufacturing_ImageSwitch_Processing :
    ID = 94471
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 23), ("Function", 16), ("Operator", 7)])
    ReverseIDs = OrderedDict([(23, "FunctionBlock"), (16, "Function"), (7, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Manufacturing_ImageSwitch_Processing.MSG_OFFSET + Manufacturing_ImageSwitch_Processing.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Manufacturing_ImageSwitch_Processing.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Manufacturing_ImageSwitch_Processing.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Manufacturing_ImageSwitch_Processing.MSG_OFFSET + Manufacturing_ImageSwitch_Processing.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Manufacturing_ImageSwitch_Processing.ID)
            self.hdr.SetDataLength(Manufacturing_ImageSwitch_Processing.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Manufacturing.ImageSwitch.Processing"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("Manufacturing.ImageSwitch.Processing", Manufacturing_ImageSwitch_Processing.ID, Manufacturing_ImageSwitch_Processing)
#    obj/CodeGenerator/Python/Manufacturing/ImageSwitch.py
#    Created 27/07/2023 at 10:10:53 from:
#        Messages = messages/Manufacturing/ImageSwitch.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Manufacturing_ImageSwitch_Get :
    ID = 94465
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 23), ("Function", 16), ("Operator", 1)])
    ReverseIDs = OrderedDict([(23, "FunctionBlock"), (16, "Function"), (1, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Manufacturing_ImageSwitch_Get.MSG_OFFSET + Manufacturing_ImageSwitch_Get.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Manufacturing_ImageSwitch_Get.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Manufacturing_ImageSwitch_Get.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Manufacturing_ImageSwitch_Get.MSG_OFFSET + Manufacturing_ImageSwitch_Get.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Manufacturing_ImageSwitch_Get.ID)
            self.hdr.SetDataLength(Manufacturing_ImageSwitch_Get.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Manufacturing.ImageSwitch.Get"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("Manufacturing.ImageSwitch.Get", Manufacturing_ImageSwitch_Get.ID, Manufacturing_ImageSwitch_Get)
#    obj/CodeGenerator/Python/Manufacturing/ImageSwitch.py
#    Created 27/07/2023 at 10:10:53 from:
#        Messages = messages/Manufacturing/ImageSwitch.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Manufacturing_ImageSwitch_Status :
    ID = 94467
    SIZE = 1
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    ImageSwitchStatusEnum = OrderedDict([("IMAGE_SWITCH_NOT_INITIATED", 0), ("IMAGE_SWITCH_COPY_IN_PROGRESS", 1), ("IMAGE_SWITCH_COPY_ERROR", 2), ("IMAGE_SWITCH_COPY_TIMEOUT", 3), ("IMAGE_SWITCH_COPY_SUCCESSFUL", 4), ("IMAGE_SWITCH_SWAP_IN_PROGRESS", 5), ("IMAGE_SWITCH_SWAP_ERROR", 6), ("IMAGE_SWITCH_SWAP_SUCCESSFUL", 7), ("IMAGE_SWITCH_COMMIT_ERROR", 8), ("IMAGE_SWITCH_COMMIT_SUCCESSFUL", 9)])
    ReverseImageSwitchStatusEnum = OrderedDict([(0, "IMAGE_SWITCH_NOT_INITIATED"), (1, "IMAGE_SWITCH_COPY_IN_PROGRESS"), (2, "IMAGE_SWITCH_COPY_ERROR"), (3, "IMAGE_SWITCH_COPY_TIMEOUT"), (4, "IMAGE_SWITCH_COPY_SUCCESSFUL"), (5, "IMAGE_SWITCH_SWAP_IN_PROGRESS"), (6, "IMAGE_SWITCH_SWAP_ERROR"), (7, "IMAGE_SWITCH_SWAP_SUCCESSFUL"), (8, "IMAGE_SWITCH_COMMIT_ERROR"), (9, "IMAGE_SWITCH_COMMIT_SUCCESSFUL")])
    IDs = OrderedDict([("FunctionBlock", 23), ("Function", 16), ("Operator", 3)])
    ReverseIDs = OrderedDict([(23, "FunctionBlock"), (16, "Function"), (3, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Manufacturing_ImageSwitch_Status.MSG_OFFSET + Manufacturing_ImageSwitch_Status.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Manufacturing_ImageSwitch_Status.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Manufacturing_ImageSwitch_Status.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Manufacturing_ImageSwitch_Status.MSG_OFFSET + Manufacturing_ImageSwitch_Status.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Manufacturing_ImageSwitch_Status.ID)
            self.hdr.SetDataLength(Manufacturing_ImageSwitch_Status.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Manufacturing.ImageSwitch.Status"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetImageSwitchStatus(self, enumAsInt=0):
        """Current status of Image Switch operation"""
        value = struct.unpack_from('B', self.rawBuffer(), Manufacturing_ImageSwitch_Status.MSG_OFFSET + 0)[0]
        if not enumAsInt:
            value = Manufacturing_ImageSwitch_Status.ReverseImageSwitchStatusEnum.get(value, value)
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetImageSwitchStatus(self, value):
        """Current status of Image Switch operation"""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Manufacturing_ImageSwitch_Status.ImageSwitchStatusEnum.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Manufacturing_ImageSwitch_Status.MSG_OFFSET + 0, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="ImageSwitchStatus",type="enumeration",units="",minVal="0",maxVal="255",description="Current status of Image Switch operation",get=GetImageSwitchStatus,set=SetImageSwitchStatus,count=1, bitfieldInfo = [], enum = [ImageSwitchStatusEnum, ReverseImageSwitchStatusEnum])\
    ]

Messaging.Register("Manufacturing.ImageSwitch.Status", Manufacturing_ImageSwitch_Status.ID, Manufacturing_ImageSwitch_Status)
#    obj/CodeGenerator/Python/Manufacturing/ImageSwitch.py
#    Created 27/07/2023 at 10:10:53 from:
#        Messages = messages/Manufacturing/ImageSwitch.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Manufacturing_ImageSwitch_Result :
    ID = 94470
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 23), ("Function", 16), ("Operator", 6)])
    ReverseIDs = OrderedDict([(23, "FunctionBlock"), (16, "Function"), (6, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Manufacturing_ImageSwitch_Result.MSG_OFFSET + Manufacturing_ImageSwitch_Result.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Manufacturing_ImageSwitch_Result.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Manufacturing_ImageSwitch_Result.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Manufacturing_ImageSwitch_Result.MSG_OFFSET + Manufacturing_ImageSwitch_Result.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Manufacturing_ImageSwitch_Result.ID)
            self.hdr.SetDataLength(Manufacturing_ImageSwitch_Result.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Manufacturing.ImageSwitch.Result"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("Manufacturing.ImageSwitch.Result", Manufacturing_ImageSwitch_Result.ID, Manufacturing_ImageSwitch_Result)
#    obj/CodeGenerator/Python/Manufacturing/ImageSwitch.py
#    Created 27/07/2023 at 10:10:53 from:
#        Messages = messages/Manufacturing/ImageSwitch.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class Manufacturing_ImageSwitch_Error :
    ID = 94468
    SIZE = 2
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    ManufacturingErrorResponseCodes = OrderedDict([("Capability Not Loaded", 0), ("Capability Already loaded", 1), ("Image copy Error", 2), ("Image swap or switch Error", 3), ("Image commit Error", 4), ("Image erase Error", 5), ("Erase Inactive Bank Image Error", 6), ("Erase Inactive Bank Image Timeout", 7)])
    ReverseManufacturingErrorResponseCodes = OrderedDict([(0, "Capability Not Loaded"), (1, "Capability Already loaded"), (2, "Image copy Error"), (3, "Image swap or switch Error"), (4, "Image commit Error"), (5, "Image erase Error"), (6, "Erase Inactive Bank Image Error"), (7, "Erase Inactive Bank Image Timeout")])
    ErrorResponseCodes = OrderedDict([("Length", 1), ("Checksum", 2), ("FBlockNotSupported", 3), ("FunctionNotSupported", 4), ("OperatorNotSupported", 5), ("InvalidData", 6), ("DataNotAvailable", 7), ("RunTime", 8), ("Timeout", 9), ("InvalidState", 10), ("DeviceNotFound", 11), ("Busy", 12), ("UnableToConnectTimeout", 13), ("UnableToConnectSourceDeviceKeyMissing", 14), ("OTAFirmwareUpdateInProgress", 15), ("LowBatteryVoltage", 16), ("ChargerNotConnected", 17), ("UpdateNotAllowed", 18), ("UnknownPortNumber", 19), ("InsecureTransport", 20), ("InvalidOTPKey", 21), ("OutOfMemory", 22), ("CryptoProcessingError", 23), ("FeatureLocked", 24), ("FunctionBlockSpecificErrorCode", 255)])
    ReverseErrorResponseCodes = OrderedDict([(1, "Length"), (2, "Checksum"), (3, "FBlockNotSupported"), (4, "FunctionNotSupported"), (5, "OperatorNotSupported"), (6, "InvalidData"), (7, "DataNotAvailable"), (8, "RunTime"), (9, "Timeout"), (10, "InvalidState"), (11, "DeviceNotFound"), (12, "Busy"), (13, "UnableToConnectTimeout"), (14, "UnableToConnectSourceDeviceKeyMissing"), (15, "OTAFirmwareUpdateInProgress"), (16, "LowBatteryVoltage"), (17, "ChargerNotConnected"), (18, "UpdateNotAllowed"), (19, "UnknownPortNumber"), (20, "InsecureTransport"), (21, "InvalidOTPKey"), (22, "OutOfMemory"), (23, "CryptoProcessingError"), (24, "FeatureLocked"), (255, "FunctionBlockSpecificErrorCode")])
    IDs = OrderedDict([("FunctionBlock", 23), ("Function", 16), ("Operator", 4)])
    ReverseIDs = OrderedDict([(23, "FunctionBlock"), (16, "Function"), (4, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(Manufacturing_ImageSwitch_Error.MSG_OFFSET + Manufacturing_ImageSwitch_Error.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, Manufacturing_ImageSwitch_Error.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, Manufacturing_ImageSwitch_Error.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(Manufacturing_ImageSwitch_Error.MSG_OFFSET + Manufacturing_ImageSwitch_Error.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(Manufacturing_ImageSwitch_Error.ID)
            self.hdr.SetDataLength(Manufacturing_ImageSwitch_Error.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "Manufacturing.ImageSwitch.Error"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetErrorCode(self, enumAsInt=0):
        """Generic BMAP error."""
        value = struct.unpack_from('B', self.rawBuffer(), Manufacturing_ImageSwitch_Error.MSG_OFFSET + 0)[0]
        if not enumAsInt:
            value = Manufacturing_ImageSwitch_Error.ReverseErrorResponseCodes.get(value, value)
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('1')
    @msg.size('1')
    @msg.count(1)
    def GetFblockSpecificErrorCode(self, enumAsInt=0):
        """Function block specific error."""
        value = struct.unpack_from('B', self.rawBuffer(), Manufacturing_ImageSwitch_Error.MSG_OFFSET + 1)[0]
        if not enumAsInt:
            value = Manufacturing_ImageSwitch_Error.ReverseManufacturingErrorResponseCodes.get(value, value)
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetErrorCode(self, value):
        """Generic BMAP error."""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Manufacturing_ImageSwitch_Error.ErrorResponseCodes.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Manufacturing_ImageSwitch_Error.MSG_OFFSET + 0, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('1')
    @msg.size('1')
    @msg.count(1)
    def SetFblockSpecificErrorCode(self, value):
        """Function block specific error."""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = Manufacturing_ImageSwitch_Error.ManufacturingErrorResponseCodes.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), Manufacturing_ImageSwitch_Error.MSG_OFFSET + 1, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="ErrorCode",type="enumeration",units="",minVal="0",maxVal="255",description="Generic BMAP error.",get=GetErrorCode,set=SetErrorCode,count=1, bitfieldInfo = [], enum = [ErrorResponseCodes, ReverseErrorResponseCodes]),\
        FieldInfo(name="FblockSpecificErrorCode",type="enumeration",units="",minVal="0",maxVal="255",description="Function block specific error.",get=GetFblockSpecificErrorCode,set=SetFblockSpecificErrorCode,count=1, bitfieldInfo = [], enum = [ManufacturingErrorResponseCodes, ReverseManufacturingErrorResponseCodes])\
    ]

Messaging.Register("Manufacturing.ImageSwitch.Error", Manufacturing_ImageSwitch_Error.ID, Manufacturing_ImageSwitch_Error)
