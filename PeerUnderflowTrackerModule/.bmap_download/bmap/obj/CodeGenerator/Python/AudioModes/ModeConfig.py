#    obj/CodeGenerator/Python/AudioModes/ModeConfig.py
#    Created 27/07/2023 at 10:09:40 from:
#        Messages = messages/AudioModes/ModeConfig.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class AudioModes_ModeConfig_Start :
    ID = 127077
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 31), ("Function", 6), ("Operator", 5)])
    ReverseIDs = OrderedDict([(31, "FunctionBlock"), (6, "Function"), (5, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(AudioModes_ModeConfig_Start.MSG_OFFSET + AudioModes_ModeConfig_Start.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, AudioModes_ModeConfig_Start.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, AudioModes_ModeConfig_Start.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(AudioModes_ModeConfig_Start.MSG_OFFSET + AudioModes_ModeConfig_Start.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(AudioModes_ModeConfig_Start.ID)
            self.hdr.SetDataLength(AudioModes_ModeConfig_Start.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "AudioModes.ModeConfig.Start"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("AudioModes.ModeConfig.Start", AudioModes_ModeConfig_Start.ID, AudioModes_ModeConfig_Start)
#    obj/CodeGenerator/Python/AudioModes/ModeConfig.py
#    Created 27/07/2023 at 10:09:40 from:
#        Messages = messages/AudioModes/ModeConfig.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class AudioModes_ModeConfig_Processing :
    ID = 127079
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 31), ("Function", 6), ("Operator", 7)])
    ReverseIDs = OrderedDict([(31, "FunctionBlock"), (6, "Function"), (7, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(AudioModes_ModeConfig_Processing.MSG_OFFSET + AudioModes_ModeConfig_Processing.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, AudioModes_ModeConfig_Processing.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, AudioModes_ModeConfig_Processing.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(AudioModes_ModeConfig_Processing.MSG_OFFSET + AudioModes_ModeConfig_Processing.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(AudioModes_ModeConfig_Processing.ID)
            self.hdr.SetDataLength(AudioModes_ModeConfig_Processing.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "AudioModes.ModeConfig.Processing"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("AudioModes.ModeConfig.Processing", AudioModes_ModeConfig_Processing.ID, AudioModes_ModeConfig_Processing)
#    obj/CodeGenerator/Python/AudioModes/ModeConfig.py
#    Created 27/07/2023 at 10:09:40 from:
#        Messages = messages/AudioModes/ModeConfig.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class AudioModes_ModeConfig_Result :
    ID = 127078
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 31), ("Function", 6), ("Operator", 6)])
    ReverseIDs = OrderedDict([(31, "FunctionBlock"), (6, "Function"), (6, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(AudioModes_ModeConfig_Result.MSG_OFFSET + AudioModes_ModeConfig_Result.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, AudioModes_ModeConfig_Result.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, AudioModes_ModeConfig_Result.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(AudioModes_ModeConfig_Result.MSG_OFFSET + AudioModes_ModeConfig_Result.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(AudioModes_ModeConfig_Result.ID)
            self.hdr.SetDataLength(AudioModes_ModeConfig_Result.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "AudioModes.ModeConfig.Result"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("AudioModes.ModeConfig.Result", AudioModes_ModeConfig_Result.ID, AudioModes_ModeConfig_Result)
#    obj/CodeGenerator/Python/AudioModes/ModeConfig.py
#    Created 27/07/2023 at 10:09:40 from:
#        Messages = messages/AudioModes/ModeConfig.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class AudioModes_ModeConfig_SetGet :
    ID = 127074
    SIZE = 39
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    SpatialAudioModeTypes = OrderedDict([("SpatialDisabled", 0), ("SpatialAudioFixedToRoom", 1), ("SpatialAudioFixedToHead", 2)])
    ReverseSpatialAudioModeTypes = OrderedDict([(0, "SpatialDisabled"), (1, "SpatialAudioFixedToRoom"), (2, "SpatialAudioFixedToHead")])
    ModePrompts = OrderedDict([("None", 0), ("Quiet", 1), ("Aware", 2), ("Transparent", 3), ("Transparency", 4), ("Masking", 5), ("Comfort", 6), ("Commute", 7), ("Outdoor", 8), ("Workout", 9), ("Home", 10), ("Work", 11), ("Music", 12), ("Focus", 13), ("Relax", 14), ("Flight", 15), ("Airport", 16), ("Driving", 17), ("Training", 18), ("Gym", 19), ("Run", 20), ("Walk", 21), ("Hike", 22), ("Talk", 23), ("Call", 24), ("Whisper", 25), ("Hearing", 26), ("Learn", 27), ("Podcast", 28), ("Audiobook", 29), ("Calm", 30), ("Sleep", 31), ("Meditate", 32), ("Yoga", 33), ("Immersion", 34)])
    ReverseModePrompts = OrderedDict([(0, "None"), (1, "Quiet"), (2, "Aware"), (3, "Transparent"), (4, "Transparency"), (5, "Masking"), (6, "Comfort"), (7, "Commute"), (8, "Outdoor"), (9, "Workout"), (10, "Home"), (11, "Work"), (12, "Music"), (13, "Focus"), (14, "Relax"), (15, "Flight"), (16, "Airport"), (17, "Driving"), (18, "Training"), (19, "Gym"), (20, "Run"), (21, "Walk"), (22, "Hike"), (23, "Talk"), (24, "Call"), (25, "Whisper"), (26, "Hearing"), (27, "Learn"), (28, "Podcast"), (29, "Audiobook"), (30, "Calm"), (31, "Sleep"), (32, "Meditate"), (33, "Yoga"), (34, "Immersion")])
    IDs = OrderedDict([("FunctionBlock", 31), ("Function", 6), ("Operator", 2)])
    ReverseIDs = OrderedDict([(31, "FunctionBlock"), (6, "Function"), (2, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(AudioModes_ModeConfig_SetGet.MSG_OFFSET + AudioModes_ModeConfig_SetGet.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, AudioModes_ModeConfig_SetGet.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, AudioModes_ModeConfig_SetGet.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(AudioModes_ModeConfig_SetGet.MSG_OFFSET + AudioModes_ModeConfig_SetGet.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(AudioModes_ModeConfig_SetGet.ID)
            self.hdr.SetDataLength(AudioModes_ModeConfig_SetGet.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "AudioModes.ModeConfig.SetGet"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetModeIndex(self):
        """Index of the audio mode that the following fields correspond to"""
        value = struct.unpack_from('B', self.rawBuffer(), AudioModes_ModeConfig_SetGet.MSG_OFFSET + 0)[0]
        return value
    
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('65535')
    @msg.offset('1')
    @msg.size('2')
    @msg.count(1)
    def GetPrompt(self, enumAsInt=0):
        """Prompt that is played when entering the audio mode"""
        value = struct.unpack_from('>H', self.rawBuffer(), AudioModes_ModeConfig_SetGet.MSG_OFFSET + 1)[0]
        if not enumAsInt:
            value = AudioModes_ModeConfig_SetGet.ReverseModePrompts.get(value, value)
        return value
    
    @msg.units('ASCII')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('3')
    @msg.size('1')
    @msg.count(32)
    def GetName(self):
        """Name corresponding to this audio mode"""
        count = 32
        if count > len(self.rawBuffer())-(AudioModes_ModeConfig_SetGet.MSG_OFFSET + 3):
            count = len(self.rawBuffer())-(AudioModes_ModeConfig_SetGet.MSG_OFFSET + 3)
    
        value = struct.unpack_from(str(count)+'s', self.rawBuffer(), AudioModes_ModeConfig_SetGet.MSG_OFFSET + 3)[0]
        ascii_len = str(value).find("\\x00")
        value = str(value)[2:ascii_len]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('35')
    @msg.size('1')
    @msg.count(1)
    def GetCNCLevel(self):
        """The CNC level to set when this audio mode is activated. This value will be ignored if the corresponding CNCMutable flag is set to false."""
        value = struct.unpack_from('B', self.rawBuffer(), AudioModes_ModeConfig_SetGet.MSG_OFFSET + 35)[0]
        return value
    
    @msg.units('Boolean')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('36')
    @msg.size('1')
    @msg.count(1)
    def GetAutoCNCEnable(self):
        """True = enable automatic noise reduction control when CNC level set to full-transparency - False = disable automatic noise reduction control functionality. This value will be ignored if the corresponding AutoCNCMutable flag is set to false."""
        value = struct.unpack_from('B', self.rawBuffer(), AudioModes_ModeConfig_SetGet.MSG_OFFSET + 36)[0]
        return value
    
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('37')
    @msg.size('1')
    @msg.count(1)
    def GetSpatialAudioMode(self, enumAsInt=0):
        """The spatial audio mode. This value will be ignored if the corresponding SpatialAudioMutable flag is set to false."""
        value = struct.unpack_from('B', self.rawBuffer(), AudioModes_ModeConfig_SetGet.MSG_OFFSET + 37)[0]
        if not enumAsInt:
            value = AudioModes_ModeConfig_SetGet.ReverseSpatialAudioModeTypes.get(value, value)
        return value
    
    @msg.units('Boolean')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('38')
    @msg.size('1')
    @msg.count(1)
    def GetANRWindToggle(self):
        """The ANR wind toggle setting. This value will be ignored if the corresponding ANRWindToggleMutable flag is set to false."""
        value = struct.unpack_from('B', self.rawBuffer(), AudioModes_ModeConfig_SetGet.MSG_OFFSET + 38)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetModeIndex(self, value):
        """Index of the audio mode that the following fields correspond to"""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), AudioModes_ModeConfig_SetGet.MSG_OFFSET + 0, tmp)
    
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('65535')
    @msg.offset('1')
    @msg.size('2')
    @msg.count(1)
    def SetPrompt(self, value):
        """Prompt that is played when entering the audio mode"""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = AudioModes_ModeConfig_SetGet.ModePrompts.get(value, defaultValue)
        tmp = min(max(value, 0), 65535)
        struct.pack_into('>H', self.rawBuffer(), AudioModes_ModeConfig_SetGet.MSG_OFFSET + 1, tmp)
    
    @msg.units('ASCII')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('3')
    @msg.size('1')
    @msg.count(32)
    def SetName(self, value):
        """Name corresponding to this audio mode"""
        tmp = value.encode('utf-8')
        struct.pack_into('32s', self.rawBuffer(), AudioModes_ModeConfig_SetGet.MSG_OFFSET + 3, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('35')
    @msg.size('1')
    @msg.count(1)
    def SetCNCLevel(self, value):
        """The CNC level to set when this audio mode is activated. This value will be ignored if the corresponding CNCMutable flag is set to false."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), AudioModes_ModeConfig_SetGet.MSG_OFFSET + 35, tmp)
    
    @msg.units('Boolean')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('36')
    @msg.size('1')
    @msg.count(1)
    def SetAutoCNCEnable(self, value):
        """True = enable automatic noise reduction control when CNC level set to full-transparency - False = disable automatic noise reduction control functionality. This value will be ignored if the corresponding AutoCNCMutable flag is set to false."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), AudioModes_ModeConfig_SetGet.MSG_OFFSET + 36, tmp)
    
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('37')
    @msg.size('1')
    @msg.count(1)
    def SetSpatialAudioMode(self, value):
        """The spatial audio mode. This value will be ignored if the corresponding SpatialAudioMutable flag is set to false."""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = AudioModes_ModeConfig_SetGet.SpatialAudioModeTypes.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), AudioModes_ModeConfig_SetGet.MSG_OFFSET + 37, tmp)
    
    @msg.units('Boolean')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('38')
    @msg.size('1')
    @msg.count(1)
    def SetANRWindToggle(self, value):
        """The ANR wind toggle setting. This value will be ignored if the corresponding ANRWindToggleMutable flag is set to false."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), AudioModes_ModeConfig_SetGet.MSG_OFFSET + 38, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="ModeIndex",type="int",units="",minVal="0",maxVal="255",description="Index of the audio mode that the following fields correspond to",get=GetModeIndex,set=SetModeIndex,count=1, bitfieldInfo = [], enum = []),\
        FieldInfo(name="Prompt",type="enumeration",units="Enum",minVal="0",maxVal="65535",description="Prompt that is played when entering the audio mode",get=GetPrompt,set=SetPrompt,count=1, bitfieldInfo = [], enum = [ModePrompts, ReverseModePrompts]),\
        FieldInfo(name="Name",type="string",units="ASCII",minVal="0",maxVal="255",description="Name corresponding to this audio mode",get=GetName,set=SetName,count=1, bitfieldInfo = [], enum = []),\
        FieldInfo(name="CNCLevel",type="int",units="",minVal="0",maxVal="255",description="The CNC level to set when this audio mode is activated. This value will be ignored if the corresponding CNCMutable flag is set to false.",get=GetCNCLevel,set=SetCNCLevel,count=1, bitfieldInfo = [], enum = []),\
        FieldInfo(name="AutoCNCEnable",type="int",units="Boolean",minVal="0",maxVal="255",description="True = enable automatic noise reduction control when CNC level set to full-transparency - False = disable automatic noise reduction control functionality. This value will be ignored if the corresponding AutoCNCMutable flag is set to false.",get=GetAutoCNCEnable,set=SetAutoCNCEnable,count=1, bitfieldInfo = [], enum = []),\
        FieldInfo(name="SpatialAudioMode",type="enumeration",units="Enum",minVal="0",maxVal="255",description="The spatial audio mode. This value will be ignored if the corresponding SpatialAudioMutable flag is set to false.",get=GetSpatialAudioMode,set=SetSpatialAudioMode,count=1, bitfieldInfo = [], enum = [SpatialAudioModeTypes, ReverseSpatialAudioModeTypes]),\
        FieldInfo(name="ANRWindToggle",type="int",units="Boolean",minVal="0",maxVal="255",description="The ANR wind toggle setting. This value will be ignored if the corresponding ANRWindToggleMutable flag is set to false.",get=GetANRWindToggle,set=SetANRWindToggle,count=1, bitfieldInfo = [], enum = [])\
    ]

Messaging.Register("AudioModes.ModeConfig.SetGet", AudioModes_ModeConfig_SetGet.ID, AudioModes_ModeConfig_SetGet)
#    obj/CodeGenerator/Python/AudioModes/ModeConfig.py
#    Created 27/07/2023 at 10:09:40 from:
#        Messages = messages/AudioModes/ModeConfig.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class AudioModes_ModeConfig_Get :
    ID = 127073
    SIZE = 1
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 31), ("Function", 6), ("Operator", 1)])
    ReverseIDs = OrderedDict([(31, "FunctionBlock"), (6, "Function"), (1, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(AudioModes_ModeConfig_Get.MSG_OFFSET + AudioModes_ModeConfig_Get.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, AudioModes_ModeConfig_Get.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, AudioModes_ModeConfig_Get.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(AudioModes_ModeConfig_Get.MSG_OFFSET + AudioModes_ModeConfig_Get.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(AudioModes_ModeConfig_Get.ID)
            self.hdr.SetDataLength(AudioModes_ModeConfig_Get.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "AudioModes.ModeConfig.Get"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetModeIndex(self):
        """Index of the mode whose information to return"""
        value = struct.unpack_from('B', self.rawBuffer(), AudioModes_ModeConfig_Get.MSG_OFFSET + 0)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetModeIndex(self, value):
        """Index of the mode whose information to return"""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), AudioModes_ModeConfig_Get.MSG_OFFSET + 0, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="ModeIndex",type="int",units="",minVal="0",maxVal="255",description="Index of the mode whose information to return",get=GetModeIndex,set=SetModeIndex,count=1, bitfieldInfo = [], enum = [])\
    ]

Messaging.Register("AudioModes.ModeConfig.Get", AudioModes_ModeConfig_Get.ID, AudioModes_ModeConfig_Get)
#    obj/CodeGenerator/Python/AudioModes/ModeConfig.py
#    Created 27/07/2023 at 10:09:40 from:
#        Messages = messages/AudioModes/ModeConfig.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class AudioModes_ModeConfig_Status :
    ID = 127075
    SIZE = 47
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    SpatialAudioModeTypes = OrderedDict([("SpatialDisabled", 0), ("SpatialAudioFixedToRoom", 1), ("SpatialAudioFixedToHead", 2)])
    ReverseSpatialAudioModeTypes = OrderedDict([(0, "SpatialDisabled"), (1, "SpatialAudioFixedToRoom"), (2, "SpatialAudioFixedToHead")])
    ModePrompts = OrderedDict([("None", 0), ("Quiet", 1), ("Aware", 2), ("Transparent", 3), ("Transparency", 4), ("Masking", 5), ("Comfort", 6), ("Commute", 7), ("Outdoor", 8), ("Workout", 9), ("Home", 10), ("Work", 11), ("Music", 12), ("Focus", 13), ("Relax", 14), ("Flight", 15), ("Airport", 16), ("Driving", 17), ("Training", 18), ("Gym", 19), ("Run", 20), ("Walk", 21), ("Hike", 22), ("Talk", 23), ("Call", 24), ("Whisper", 25), ("Hearing", 26), ("Learn", 27), ("Podcast", 28), ("Audiobook", 29), ("Calm", 30), ("Sleep", 31), ("Meditate", 32), ("Yoga", 33), ("Immersion", 34)])
    ReverseModePrompts = OrderedDict([(0, "None"), (1, "Quiet"), (2, "Aware"), (3, "Transparent"), (4, "Transparency"), (5, "Masking"), (6, "Comfort"), (7, "Commute"), (8, "Outdoor"), (9, "Workout"), (10, "Home"), (11, "Work"), (12, "Music"), (13, "Focus"), (14, "Relax"), (15, "Flight"), (16, "Airport"), (17, "Driving"), (18, "Training"), (19, "Gym"), (20, "Run"), (21, "Walk"), (22, "Hike"), (23, "Talk"), (24, "Call"), (25, "Whisper"), (26, "Hearing"), (27, "Learn"), (28, "Podcast"), (29, "Audiobook"), (30, "Calm"), (31, "Sleep"), (32, "Meditate"), (33, "Yoga"), (34, "Immersion")])
    IDs = OrderedDict([("FunctionBlock", 31), ("Function", 6), ("Operator", 3)])
    ReverseIDs = OrderedDict([(31, "FunctionBlock"), (6, "Function"), (3, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(AudioModes_ModeConfig_Status.MSG_OFFSET + AudioModes_ModeConfig_Status.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, AudioModes_ModeConfig_Status.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, AudioModes_ModeConfig_Status.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(AudioModes_ModeConfig_Status.MSG_OFFSET + AudioModes_ModeConfig_Status.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(AudioModes_ModeConfig_Status.ID)
            self.hdr.SetDataLength(AudioModes_ModeConfig_Status.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "AudioModes.ModeConfig.Status"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetModeIndex(self):
        """Index of the audio mode that the following fields correspond to"""
        value = struct.unpack_from('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 0)[0]
        return value
    
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('65535')
    @msg.offset('1')
    @msg.size('2')
    @msg.count(1)
    def GetPrompt(self, enumAsInt=0):
        """Prompt configured for this mode"""
        value = struct.unpack_from('>H', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 1)[0]
        if not enumAsInt:
            value = AudioModes_ModeConfig_Status.ReverseModePrompts.get(value, value)
        return value
    
    @msg.units('Boolean')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('3')
    @msg.size('1')
    @msg.count(1)
    def GetIsCustom(self):
        """Whether or not this mode is user-configurable"""
        value = struct.unpack_from('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 3)[0]
        return value
    
    @msg.units('Boolean')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('4')
    @msg.size('1')
    @msg.count(1)
    def GetIsConfigured(self):
        """Whether or not this mode has been configured by the user. Always False on Bose-defined modes."""
        value = struct.unpack_from('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 4)[0]
        return value
    
    @msg.units('Boolean')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('5')
    @msg.size('1')
    @msg.count(1)
    def GetIsFavorite(self):
        """Whether or not this mode is favorited (part of the carousel)"""
        value = struct.unpack_from('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 5)[0]
        return value
    
    @msg.units('ASCII')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('6')
    @msg.size('1')
    @msg.count(32)
    def GetName(self):
        """Name corresponding to this audio mode"""
        count = 32
        if count > len(self.rawBuffer())-(AudioModes_ModeConfig_Status.MSG_OFFSET + 6):
            count = len(self.rawBuffer())-(AudioModes_ModeConfig_Status.MSG_OFFSET + 6)
    
        value = struct.unpack_from(str(count)+'s', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 6)[0]
        ascii_len = str(value).find("\\x00")
        value = str(value)[2:ascii_len]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('4294967295')
    @msg.offset('38')
    @msg.size('4')
    @msg.count(1)
    def GetIsFeatureMutableFlags(self):
        """Bitfield denoting which features are mutable on this audio mode. Any feature bit set to false in this bitfield will have their parameter values ignored by the firmware."""
        value = struct.unpack_from('>L', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 38)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('38')
    @msg.size('0')
    @msg.count(1)
    def GetCNCMutable(self):
        """CNCMutable - If set, indicates that CNC is mutable. If not set, CNC is immutable."""
        value = (self.GetIsFeatureMutableFlags() >> 0) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('38')
    @msg.size('0')
    @msg.count(1)
    def GetAutoCNCMutable(self):
        """AutoCNCMutable - If set, indicates that automatic noise reduction control is mutable. If not set, automatic noise reduction control is immutable."""
        value = (self.GetIsFeatureMutableFlags() >> 1) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('38')
    @msg.size('0')
    @msg.count(1)
    def GetSpatialAudioMutable(self):
        """SpatialAudioMutable - If set, indicates that spatial audio is mutable. If not set, spatial audio is immutable."""
        value = (self.GetIsFeatureMutableFlags() >> 2) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('38')
    @msg.size('0')
    @msg.count(1)
    def GetANRWindToggleMutable(self):
        """ANRWindToggleMutable - If set, indicates that the ANR wind toggle is mutable. If not set, ANR wind toggle is immutable."""
        value = (self.GetIsFeatureMutableFlags() >> 3) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('268435455')
    @msg.offset('38')
    @msg.size('0')
    @msg.count(1)
    def GetUnassigned(self):
        """Unassigned"""
        value = (self.GetIsFeatureMutableFlags() >> 4) & 0xfffffff
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('42')
    @msg.size('1')
    @msg.count(1)
    def GetCNCLevel(self):
        """The CNC level to set when this audio mode is activated. This value will be ignored if the corresponding CNCMutable flag is set to false."""
        value = struct.unpack_from('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 42)[0]
        return value
    
    @msg.units('Boolean')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('43')
    @msg.size('1')
    @msg.count(1)
    def GetAutoCNCEnable(self):
        """True = enable automatic noise reduction control when CNC level set to full-transparency - False = disable automatic noise reduction control functionality. This value will be ignored if the corresponding AutoCNCMutable flag is set to false."""
        value = struct.unpack_from('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 43)[0]
        return value
    
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('44')
    @msg.size('1')
    @msg.count(1)
    def GetSpatialAudioMode(self, enumAsInt=0):
        """The current spatial audio mode."""
        value = struct.unpack_from('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 44)[0]
        if not enumAsInt:
            value = AudioModes_ModeConfig_Status.ReverseSpatialAudioModeTypes.get(value, value)
        return value
    
    @msg.units('Boolean')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('45')
    @msg.size('1')
    @msg.count(1)
    def GetIsRenamable(self):
        """Whether or not this mode can be renamed."""
        value = struct.unpack_from('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 45)[0]
        return value
    
    @msg.units('Boolean')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('46')
    @msg.size('1')
    @msg.count(1)
    def GetANRWindToggle(self):
        """The current ANR wind toggle setting. When enabled, there will be less wind while in full ANR. Note that this will override the ANR level setting and force it to full ANR (level 0)."""
        value = struct.unpack_from('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 46)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetModeIndex(self, value):
        """Index of the audio mode that the following fields correspond to"""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 0, tmp)
    
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('65535')
    @msg.offset('1')
    @msg.size('2')
    @msg.count(1)
    def SetPrompt(self, value):
        """Prompt configured for this mode"""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = AudioModes_ModeConfig_Status.ModePrompts.get(value, defaultValue)
        tmp = min(max(value, 0), 65535)
        struct.pack_into('>H', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 1, tmp)
    
    @msg.units('Boolean')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('3')
    @msg.size('1')
    @msg.count(1)
    def SetIsCustom(self, value):
        """Whether or not this mode is user-configurable"""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 3, tmp)
    
    @msg.units('Boolean')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('4')
    @msg.size('1')
    @msg.count(1)
    def SetIsConfigured(self, value):
        """Whether or not this mode has been configured by the user. Always False on Bose-defined modes."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 4, tmp)
    
    @msg.units('Boolean')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('5')
    @msg.size('1')
    @msg.count(1)
    def SetIsFavorite(self, value):
        """Whether or not this mode is favorited (part of the carousel)"""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 5, tmp)
    
    @msg.units('ASCII')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('6')
    @msg.size('1')
    @msg.count(32)
    def SetName(self, value):
        """Name corresponding to this audio mode"""
        tmp = value.encode('utf-8')
        struct.pack_into('32s', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 6, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('4294967295')
    @msg.offset('38')
    @msg.size('4')
    @msg.count(1)
    def SetIsFeatureMutableFlags(self, value):
        """Bitfield denoting which features are mutable on this audio mode. Any feature bit set to false in this bitfield will have their parameter values ignored by the firmware."""
        tmp = min(max(value, 0), 4294967295)
        struct.pack_into('>L', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 38, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('38')
    @msg.size('0')
    @msg.count(1)
    def SetCNCMutable(self, value):
        """CNCMutable - If set, indicates that CNC is mutable. If not set, CNC is immutable."""
        tmp = min(max(value, 0), 1)
        self.SetIsFeatureMutableFlags((self.GetIsFeatureMutableFlags() & ~(0x1 << 0)) | ((tmp & 0x1) << 0))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('38')
    @msg.size('0')
    @msg.count(1)
    def SetAutoCNCMutable(self, value):
        """AutoCNCMutable - If set, indicates that automatic noise reduction control is mutable. If not set, automatic noise reduction control is immutable."""
        tmp = min(max(value, 0), 1)
        self.SetIsFeatureMutableFlags((self.GetIsFeatureMutableFlags() & ~(0x1 << 1)) | ((tmp & 0x1) << 1))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('38')
    @msg.size('0')
    @msg.count(1)
    def SetSpatialAudioMutable(self, value):
        """SpatialAudioMutable - If set, indicates that spatial audio is mutable. If not set, spatial audio is immutable."""
        tmp = min(max(value, 0), 1)
        self.SetIsFeatureMutableFlags((self.GetIsFeatureMutableFlags() & ~(0x1 << 2)) | ((tmp & 0x1) << 2))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('38')
    @msg.size('0')
    @msg.count(1)
    def SetANRWindToggleMutable(self, value):
        """ANRWindToggleMutable - If set, indicates that the ANR wind toggle is mutable. If not set, ANR wind toggle is immutable."""
        tmp = min(max(value, 0), 1)
        self.SetIsFeatureMutableFlags((self.GetIsFeatureMutableFlags() & ~(0x1 << 3)) | ((tmp & 0x1) << 3))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('268435455')
    @msg.offset('38')
    @msg.size('0')
    @msg.count(1)
    def SetUnassigned(self, value):
        """Unassigned"""
        tmp = min(max(value, 0), 268435455)
        self.SetIsFeatureMutableFlags((self.GetIsFeatureMutableFlags() & ~(0xfffffff << 4)) | ((tmp & 0xfffffff) << 4))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('42')
    @msg.size('1')
    @msg.count(1)
    def SetCNCLevel(self, value):
        """The CNC level to set when this audio mode is activated. This value will be ignored if the corresponding CNCMutable flag is set to false."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 42, tmp)
    
    @msg.units('Boolean')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('43')
    @msg.size('1')
    @msg.count(1)
    def SetAutoCNCEnable(self, value):
        """True = enable automatic noise reduction control when CNC level set to full-transparency - False = disable automatic noise reduction control functionality. This value will be ignored if the corresponding AutoCNCMutable flag is set to false."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 43, tmp)
    
    @msg.units('Enum')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('44')
    @msg.size('1')
    @msg.count(1)
    def SetSpatialAudioMode(self, value):
        """The current spatial audio mode."""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = AudioModes_ModeConfig_Status.SpatialAudioModeTypes.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 44, tmp)
    
    @msg.units('Boolean')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('45')
    @msg.size('1')
    @msg.count(1)
    def SetIsRenamable(self, value):
        """Whether or not this mode can be renamed."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 45, tmp)
    
    @msg.units('Boolean')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('46')
    @msg.size('1')
    @msg.count(1)
    def SetANRWindToggle(self, value):
        """The current ANR wind toggle setting. When enabled, there will be less wind while in full ANR. Note that this will override the ANR level setting and force it to full ANR (level 0)."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), AudioModes_ModeConfig_Status.MSG_OFFSET + 46, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="ModeIndex",type="int",units="",minVal="0",maxVal="255",description="Index of the audio mode that the following fields correspond to",get=GetModeIndex,set=SetModeIndex,count=1, bitfieldInfo = [], enum = []),\
        FieldInfo(name="Prompt",type="enumeration",units="Enum",minVal="0",maxVal="65535",description="Prompt configured for this mode",get=GetPrompt,set=SetPrompt,count=1, bitfieldInfo = [], enum = [ModePrompts, ReverseModePrompts]),\
        FieldInfo(name="IsCustom",type="int",units="Boolean",minVal="0",maxVal="255",description="Whether or not this mode is user-configurable",get=GetIsCustom,set=SetIsCustom,count=1, bitfieldInfo = [], enum = []),\
        FieldInfo(name="IsConfigured",type="int",units="Boolean",minVal="0",maxVal="255",description="Whether or not this mode has been configured by the user. Always False on Bose-defined modes.",get=GetIsConfigured,set=SetIsConfigured,count=1, bitfieldInfo = [], enum = []),\
        FieldInfo(name="IsFavorite",type="int",units="Boolean",minVal="0",maxVal="255",description="Whether or not this mode is favorited (part of the carousel)",get=GetIsFavorite,set=SetIsFavorite,count=1, bitfieldInfo = [], enum = []),\
        FieldInfo(name="Name",type="string",units="ASCII",minVal="0",maxVal="255",description="Name corresponding to this audio mode",get=GetName,set=SetName,count=1, bitfieldInfo = [], enum = []),\
        FieldInfo(name="IsFeatureMutableFlags",type="int",units="",minVal="0",maxVal="4294967295",description="Bitfield denoting which features are mutable on this audio mode. Any feature bit set to false in this bitfield will have their parameter values ignored by the firmware.",get=GetIsFeatureMutableFlags,set=SetIsFeatureMutableFlags,count=1, bitfieldInfo = [\
            BitFieldInfo(name="CNCMutable",type="int",units="",minVal="0",maxVal="1",description="CNCMutable - If set, indicates that CNC is mutable. If not set, CNC is immutable.",get=GetCNCMutable,set=SetCNCMutable, enum = []),\
            BitFieldInfo(name="AutoCNCMutable",type="int",units="",minVal="0",maxVal="1",description="AutoCNCMutable - If set, indicates that automatic noise reduction control is mutable. If not set, automatic noise reduction control is immutable.",get=GetAutoCNCMutable,set=SetAutoCNCMutable, enum = []),\
            BitFieldInfo(name="SpatialAudioMutable",type="int",units="",minVal="0",maxVal="1",description="SpatialAudioMutable - If set, indicates that spatial audio is mutable. If not set, spatial audio is immutable.",get=GetSpatialAudioMutable,set=SetSpatialAudioMutable, enum = []),\
            BitFieldInfo(name="ANRWindToggleMutable",type="int",units="",minVal="0",maxVal="1",description="ANRWindToggleMutable - If set, indicates that the ANR wind toggle is mutable. If not set, ANR wind toggle is immutable.",get=GetANRWindToggleMutable,set=SetANRWindToggleMutable, enum = []),\
            BitFieldInfo(name="Unassigned",type="int",units="",minVal="0",maxVal="268435455",description="Unassigned",get=GetUnassigned,set=SetUnassigned, enum = [])], enum = []),\
        FieldInfo(name="CNCLevel",type="int",units="",minVal="0",maxVal="255",description="The CNC level to set when this audio mode is activated. This value will be ignored if the corresponding CNCMutable flag is set to false.",get=GetCNCLevel,set=SetCNCLevel,count=1, bitfieldInfo = [], enum = []),\
        FieldInfo(name="AutoCNCEnable",type="int",units="Boolean",minVal="0",maxVal="255",description="True = enable automatic noise reduction control when CNC level set to full-transparency - False = disable automatic noise reduction control functionality. This value will be ignored if the corresponding AutoCNCMutable flag is set to false.",get=GetAutoCNCEnable,set=SetAutoCNCEnable,count=1, bitfieldInfo = [], enum = []),\
        FieldInfo(name="SpatialAudioMode",type="enumeration",units="Enum",minVal="0",maxVal="255",description="The current spatial audio mode.",get=GetSpatialAudioMode,set=SetSpatialAudioMode,count=1, bitfieldInfo = [], enum = [SpatialAudioModeTypes, ReverseSpatialAudioModeTypes]),\
        FieldInfo(name="IsRenamable",type="int",units="Boolean",minVal="0",maxVal="255",description="Whether or not this mode can be renamed.",get=GetIsRenamable,set=SetIsRenamable,count=1, bitfieldInfo = [], enum = []),\
        FieldInfo(name="ANRWindToggle",type="int",units="Boolean",minVal="0",maxVal="255",description="The current ANR wind toggle setting. When enabled, there will be less wind while in full ANR. Note that this will override the ANR level setting and force it to full ANR (level 0).",get=GetANRWindToggle,set=SetANRWindToggle,count=1, bitfieldInfo = [], enum = [])\
    ]

Messaging.Register("AudioModes.ModeConfig.Status", AudioModes_ModeConfig_Status.ID, AudioModes_ModeConfig_Status)
