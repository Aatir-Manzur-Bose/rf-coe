#    obj/CodeGenerator/Python/FirmwareUpdate/Run.py
#    Created 27/07/2023 at 10:10:44 from:
#        Messages = messages/FirmwareUpdate/Run.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class FirmwareUpdate_Run_Get :
    ID = 12385
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 3), ("Function", 6), ("Operator", 1)])
    ReverseIDs = OrderedDict([(3, "FunctionBlock"), (6, "Function"), (1, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(FirmwareUpdate_Run_Get.MSG_OFFSET + FirmwareUpdate_Run_Get.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, FirmwareUpdate_Run_Get.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, FirmwareUpdate_Run_Get.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(FirmwareUpdate_Run_Get.MSG_OFFSET + FirmwareUpdate_Run_Get.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(FirmwareUpdate_Run_Get.ID)
            self.hdr.SetDataLength(FirmwareUpdate_Run_Get.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "FirmwareUpdate.Run.Get"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("FirmwareUpdate.Run.Get", FirmwareUpdate_Run_Get.ID, FirmwareUpdate_Run_Get)
#    obj/CodeGenerator/Python/FirmwareUpdate/Run.py
#    Created 27/07/2023 at 10:10:44 from:
#        Messages = messages/FirmwareUpdate/Run.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class FirmwareUpdate_Run_Start :
    ID = 12389
    SIZE = 1
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 3), ("Function", 6), ("Operator", 5)])
    ReverseIDs = OrderedDict([(3, "FunctionBlock"), (6, "Function"), (5, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(FirmwareUpdate_Run_Start.MSG_OFFSET + FirmwareUpdate_Run_Start.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, FirmwareUpdate_Run_Start.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, FirmwareUpdate_Run_Start.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(FirmwareUpdate_Run_Start.MSG_OFFSET + FirmwareUpdate_Run_Start.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(FirmwareUpdate_Run_Start.ID)
            self.hdr.SetDataLength(FirmwareUpdate_Run_Start.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "FirmwareUpdate.Run.Start"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetFwuMode(self):
        """Command to start applying the downloaded update image to the product. If the command is sent without a FwuMode byte in the payload, the update will be applied immediately. If the payload includes the FwuMode byte, the FwuMode byte will control when and how the unit will apply the update.  If the FwuMode byte equals 0x01, the update will be applied after the next power cycle.  If the FwuMode byte equals 0x02, the product will apply the update to itself and all its subcomponents as soon as all the subcomponents are present.  If the product supports this mode (0x02), the client should use it unless the product is being updated in a development or manufacturing environment.  Sending an immediate update command (i.e., no FwuMode byte in the payload) will cause the device to update immediately, and may prevent it from updating any subcomponents (such as a paired earbud).  Any other data value for FwuMode results in an error.  Before sending a FwuMode byte, the client must check that the mode is supported by sending a Run.Get and parsing the Run.Status response."""
        value = struct.unpack_from('B', self.rawBuffer(), FirmwareUpdate_Run_Start.MSG_OFFSET + 0)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetFwuMode(self, value):
        """Command to start applying the downloaded update image to the product. If the command is sent without a FwuMode byte in the payload, the update will be applied immediately. If the payload includes the FwuMode byte, the FwuMode byte will control when and how the unit will apply the update.  If the FwuMode byte equals 0x01, the update will be applied after the next power cycle.  If the FwuMode byte equals 0x02, the product will apply the update to itself and all its subcomponents as soon as all the subcomponents are present.  If the product supports this mode (0x02), the client should use it unless the product is being updated in a development or manufacturing environment.  Sending an immediate update command (i.e., no FwuMode byte in the payload) will cause the device to update immediately, and may prevent it from updating any subcomponents (such as a paired earbud).  Any other data value for FwuMode results in an error.  Before sending a FwuMode byte, the client must check that the mode is supported by sending a Run.Get and parsing the Run.Status response."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), FirmwareUpdate_Run_Start.MSG_OFFSET + 0, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="FwuMode",type="int",units="",minVal="0",maxVal="255",description="Command to start applying the downloaded update image to the product. If the command is sent without a FwuMode byte in the payload, the update will be applied immediately. If the payload includes the FwuMode byte, the FwuMode byte will control when and how the unit will apply the update.  If the FwuMode byte equals 0x01, the update will be applied after the next power cycle.  If the FwuMode byte equals 0x02, the product will apply the update to itself and all its subcomponents as soon as all the subcomponents are present.  If the product supports this mode (0x02), the client should use it unless the product is being updated in a development or manufacturing environment.  Sending an immediate update command (i.e., no FwuMode byte in the payload) will cause the device to update immediately, and may prevent it from updating any subcomponents (such as a paired earbud).  Any other data value for FwuMode results in an error.  Before sending a FwuMode byte, the client must check that the mode is supported by sending a Run.Get and parsing the Run.Status response.",get=GetFwuMode,set=SetFwuMode,count=1, bitfieldInfo = [], enum = [])\
    ]

Messaging.Register("FirmwareUpdate.Run.Start", FirmwareUpdate_Run_Start.ID, FirmwareUpdate_Run_Start)
#    obj/CodeGenerator/Python/FirmwareUpdate/Run.py
#    Created 27/07/2023 at 10:10:44 from:
#        Messages = messages/FirmwareUpdate/Run.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class FirmwareUpdate_Run_Processing :
    ID = 12391
    SIZE = 0
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 3), ("Function", 6), ("Operator", 7)])
    ReverseIDs = OrderedDict([(3, "FunctionBlock"), (6, "Function"), (7, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(FirmwareUpdate_Run_Processing.MSG_OFFSET + FirmwareUpdate_Run_Processing.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, FirmwareUpdate_Run_Processing.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, FirmwareUpdate_Run_Processing.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(FirmwareUpdate_Run_Processing.MSG_OFFSET + FirmwareUpdate_Run_Processing.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(FirmwareUpdate_Run_Processing.ID)
            self.hdr.SetDataLength(FirmwareUpdate_Run_Processing.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "FirmwareUpdate.Run.Processing"
    # Accessors

    # Reflection information
    fields = [ \
    ]

Messaging.Register("FirmwareUpdate.Run.Processing", FirmwareUpdate_Run_Processing.ID, FirmwareUpdate_Run_Processing)
#    obj/CodeGenerator/Python/FirmwareUpdate/Run.py
#    Created 27/07/2023 at 10:10:44 from:
#        Messages = messages/FirmwareUpdate/Run.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class FirmwareUpdate_Run_Status :
    ID = 12387
    SIZE = 2
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 3), ("Function", 6), ("Operator", 3)])
    ReverseIDs = OrderedDict([(3, "FunctionBlock"), (6, "Function"), (3, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(FirmwareUpdate_Run_Status.MSG_OFFSET + FirmwareUpdate_Run_Status.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, FirmwareUpdate_Run_Status.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, FirmwareUpdate_Run_Status.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(FirmwareUpdate_Run_Status.MSG_OFFSET + FirmwareUpdate_Run_Status.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(FirmwareUpdate_Run_Status.ID)
            self.hdr.SetDataLength(FirmwareUpdate_Run_Status.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "FirmwareUpdate.Run.Status"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetFwuStatus(self):
        """FwuStatus will be 0x00 if the product is ready to apply the update and all conditions are met to perform the operation (i.e.  battery level is sufficiently high, etc). It will equal 0x01 if the product is not ready to apply the update because it has not received and validated an image, or has encountered an error condition.  If the product returns a value of 0x02 in this field, it has received and validated the image but cannot apply it because the battery is too low.  In this case, if the FwuInformation field indicates that the update can be deferred, it is safe to send a the FirmwareUpdate.Run.Start command to tell it to autonomously apply the update when conditions improve."""
        value = struct.unpack_from('B', self.rawBuffer(), FirmwareUpdate_Run_Status.MSG_OFFSET + 0)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('1')
    @msg.size('1')
    @msg.count(1)
    def GetFwuInformation(self):
        """Optional field containing additional information about running the update. If this field is not present, client applications must assume that no options in this field are supported, i.e. set to 0."""
        value = struct.unpack_from('B', self.rawBuffer(), FirmwareUpdate_Run_Status.MSG_OFFSET + 1)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetFwuDeferrable(self):
        """0 -- Firmware updates may not be deferred, 1 -- firmware updates may be deferred. If firmware updates may not be deferred, client apps must not request a deferred update by sending a .Run.Start command with FwuMode equal to 0x01."""
        value = (self.GetFwuInformation() >> 0) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetFwuCaseAssist(self):
        """0 -- Firmware update does not require product be placed in a charging case, 1 -- firmware update requires that product be placed in a charging case in order for the update to take place. If this bit is set, the Run.Start command should include a FwuMode value of 0x02, otherwise, the device will apply the update only to itself, and may not update its subcomponent devices (such as a paired earbud)."""
        value = (self.GetFwuInformation() >> 1) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetFwuOTAModeRequired(self):
        """0 -- Updates may be transferred in normal operating mode (that is, while the device is in use). 1 -- Updates must be transferred in a special OTA mode, during which normal use of the product is not possible.  User consent should be obtained before starting the update."""
        value = (self.GetFwuInformation() >> 2) & 0x1
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('31')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def GetFwuInformationReserved(self):
        """Reserved for future use. Must be set to zero while they are reserved."""
        value = (self.GetFwuInformation() >> 3) & 0x1f
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetFwuStatus(self, value):
        """FwuStatus will be 0x00 if the product is ready to apply the update and all conditions are met to perform the operation (i.e.  battery level is sufficiently high, etc). It will equal 0x01 if the product is not ready to apply the update because it has not received and validated an image, or has encountered an error condition.  If the product returns a value of 0x02 in this field, it has received and validated the image but cannot apply it because the battery is too low.  In this case, if the FwuInformation field indicates that the update can be deferred, it is safe to send a the FirmwareUpdate.Run.Start command to tell it to autonomously apply the update when conditions improve."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), FirmwareUpdate_Run_Status.MSG_OFFSET + 0, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('1')
    @msg.size('1')
    @msg.count(1)
    def SetFwuInformation(self, value):
        """Optional field containing additional information about running the update. If this field is not present, client applications must assume that no options in this field are supported, i.e. set to 0."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), FirmwareUpdate_Run_Status.MSG_OFFSET + 1, tmp)
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetFwuDeferrable(self, value):
        """0 -- Firmware updates may not be deferred, 1 -- firmware updates may be deferred. If firmware updates may not be deferred, client apps must not request a deferred update by sending a .Run.Start command with FwuMode equal to 0x01."""
        tmp = min(max(value, 0), 1)
        self.SetFwuInformation((self.GetFwuInformation() & ~(0x1 << 0)) | ((tmp & 0x1) << 0))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetFwuCaseAssist(self, value):
        """0 -- Firmware update does not require product be placed in a charging case, 1 -- firmware update requires that product be placed in a charging case in order for the update to take place. If this bit is set, the Run.Start command should include a FwuMode value of 0x02, otherwise, the device will apply the update only to itself, and may not update its subcomponent devices (such as a paired earbud)."""
        tmp = min(max(value, 0), 1)
        self.SetFwuInformation((self.GetFwuInformation() & ~(0x1 << 1)) | ((tmp & 0x1) << 1))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('1')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetFwuOTAModeRequired(self, value):
        """0 -- Updates may be transferred in normal operating mode (that is, while the device is in use). 1 -- Updates must be transferred in a special OTA mode, during which normal use of the product is not possible.  User consent should be obtained before starting the update."""
        tmp = min(max(value, 0), 1)
        self.SetFwuInformation((self.GetFwuInformation() & ~(0x1 << 2)) | ((tmp & 0x1) << 2))
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('31')
    @msg.offset('1')
    @msg.size('0')
    @msg.count(1)
    def SetFwuInformationReserved(self, value):
        """Reserved for future use. Must be set to zero while they are reserved."""
        tmp = min(max(value, 0), 31)
        self.SetFwuInformation((self.GetFwuInformation() & ~(0x1f << 3)) | ((tmp & 0x1f) << 3))
    

    # Reflection information
    fields = [ \
        FieldInfo(name="FwuStatus",type="int",units="",minVal="0",maxVal="255",description="FwuStatus will be 0x00 if the product is ready to apply the update and all conditions are met to perform the operation (i.e.  battery level is sufficiently high, etc). It will equal 0x01 if the product is not ready to apply the update because it has not received and validated an image, or has encountered an error condition.  If the product returns a value of 0x02 in this field, it has received and validated the image but cannot apply it because the battery is too low.  In this case, if the FwuInformation field indicates that the update can be deferred, it is safe to send a the FirmwareUpdate.Run.Start command to tell it to autonomously apply the update when conditions improve.",get=GetFwuStatus,set=SetFwuStatus,count=1, bitfieldInfo = [], enum = []),\
        FieldInfo(name="FwuInformation",type="int",units="",minVal="0",maxVal="255",description="Optional field containing additional information about running the update. If this field is not present, client applications must assume that no options in this field are supported, i.e. set to 0.",get=GetFwuInformation,set=SetFwuInformation,count=1, bitfieldInfo = [\
            BitFieldInfo(name="FwuDeferrable",type="int",units="",minVal="0",maxVal="1",description="0 -- Firmware updates may not be deferred, 1 -- firmware updates may be deferred. If firmware updates may not be deferred, client apps must not request a deferred update by sending a .Run.Start command with FwuMode equal to 0x01.",get=GetFwuDeferrable,set=SetFwuDeferrable, enum = []),\
            BitFieldInfo(name="FwuCaseAssist",type="int",units="",minVal="0",maxVal="1",description="0 -- Firmware update does not require product be placed in a charging case, 1 -- firmware update requires that product be placed in a charging case in order for the update to take place. If this bit is set, the Run.Start command should include a FwuMode value of 0x02, otherwise, the device will apply the update only to itself, and may not update its subcomponent devices (such as a paired earbud).",get=GetFwuCaseAssist,set=SetFwuCaseAssist, enum = []),\
            BitFieldInfo(name="FwuOTAModeRequired",type="int",units="",minVal="0",maxVal="1",description="0 -- Updates may be transferred in normal operating mode (that is, while the device is in use). 1 -- Updates must be transferred in a special OTA mode, during which normal use of the product is not possible.  User consent should be obtained before starting the update.",get=GetFwuOTAModeRequired,set=SetFwuOTAModeRequired, enum = []),\
            BitFieldInfo(name="FwuInformationReserved",type="int",units="",minVal="0",maxVal="31",description="Reserved for future use. Must be set to zero while they are reserved.",get=GetFwuInformationReserved,set=SetFwuInformationReserved, enum = [])], enum = [])\
    ]

Messaging.Register("FirmwareUpdate.Run.Status", FirmwareUpdate_Run_Status.ID, FirmwareUpdate_Run_Status)
#    obj/CodeGenerator/Python/FirmwareUpdate/Run.py
#    Created 27/07/2023 at 10:10:44 from:
#        Messages = messages/FirmwareUpdate/Run.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class FirmwareUpdate_Run_Error :
    ID = 12388
    SIZE = 1
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    ErrorResponseCodes = OrderedDict([("Length", 1), ("Checksum", 2), ("FBlockNotSupported", 3), ("FunctionNotSupported", 4), ("OperatorNotSupported", 5), ("InvalidData", 6), ("DataNotAvailable", 7), ("RunTime", 8), ("Timeout", 9), ("InvalidState", 10), ("DeviceNotFound", 11), ("Busy", 12), ("UnableToConnectTimeout", 13), ("UnableToConnectSourceDeviceKeyMissing", 14), ("OTAFirmwareUpdateInProgress", 15), ("LowBatteryVoltage", 16), ("ChargerNotConnected", 17), ("UpdateNotAllowed", 18), ("UnknownPortNumber", 19), ("InsecureTransport", 20), ("InvalidOTPKey", 21), ("OutOfMemory", 22), ("CryptoProcessingError", 23), ("FeatureLocked", 24), ("FunctionBlockSpecificErrorCode", 255)])
    ReverseErrorResponseCodes = OrderedDict([(1, "Length"), (2, "Checksum"), (3, "FBlockNotSupported"), (4, "FunctionNotSupported"), (5, "OperatorNotSupported"), (6, "InvalidData"), (7, "DataNotAvailable"), (8, "RunTime"), (9, "Timeout"), (10, "InvalidState"), (11, "DeviceNotFound"), (12, "Busy"), (13, "UnableToConnectTimeout"), (14, "UnableToConnectSourceDeviceKeyMissing"), (15, "OTAFirmwareUpdateInProgress"), (16, "LowBatteryVoltage"), (17, "ChargerNotConnected"), (18, "UpdateNotAllowed"), (19, "UnknownPortNumber"), (20, "InsecureTransport"), (21, "InvalidOTPKey"), (22, "OutOfMemory"), (23, "CryptoProcessingError"), (24, "FeatureLocked"), (255, "FunctionBlockSpecificErrorCode")])
    IDs = OrderedDict([("FunctionBlock", 3), ("Function", 6), ("Operator", 4)])
    ReverseIDs = OrderedDict([(3, "FunctionBlock"), (6, "Function"), (4, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(FirmwareUpdate_Run_Error.MSG_OFFSET + FirmwareUpdate_Run_Error.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, FirmwareUpdate_Run_Error.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, FirmwareUpdate_Run_Error.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(FirmwareUpdate_Run_Error.MSG_OFFSET + FirmwareUpdate_Run_Error.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(FirmwareUpdate_Run_Error.ID)
            self.hdr.SetDataLength(FirmwareUpdate_Run_Error.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "FirmwareUpdate.Run.Error"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetErrorCodes(self, enumAsInt=0):
        """"""
        value = struct.unpack_from('B', self.rawBuffer(), FirmwareUpdate_Run_Error.MSG_OFFSET + 0)[0]
        if not enumAsInt:
            value = FirmwareUpdate_Run_Error.ReverseErrorResponseCodes.get(value, value)
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetErrorCodes(self, value):
        """"""
        defaultValue = 0
        try:
            value = int(float(value))
        except ValueError:
            pass
        if isinstance(value, int) or value.isdigit():
            defaultValue = int(value)
        value = FirmwareUpdate_Run_Error.ErrorResponseCodes.get(value, defaultValue)
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), FirmwareUpdate_Run_Error.MSG_OFFSET + 0, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="ErrorCodes",type="enumeration",units="",minVal="0",maxVal="255",description="",get=GetErrorCodes,set=SetErrorCodes,count=1, bitfieldInfo = [], enum = [ErrorResponseCodes, ReverseErrorResponseCodes])\
    ]

Messaging.Register("FirmwareUpdate.Run.Error", FirmwareUpdate_Run_Error.ID, FirmwareUpdate_Run_Error)
#    obj/CodeGenerator/Python/FirmwareUpdate/Run.py
#    Created 27/07/2023 at 10:10:44 from:
#        Messages = messages/FirmwareUpdate/Run.yaml
#        Template = Template.py
#        Language = python
#
#                     AUTOGENERATED FILE, DO NOT EDIT
import struct
import ctypes
from collections import OrderedDict
from msgtools.lib.messaging import *
import msgtools.lib.messaging as msg

class FirmwareUpdate_Run_Result :
    ID = 12390
    SIZE = 1
    MSG_OFFSET = Messaging.hdrSize
    # Enumerations
    IDs = OrderedDict([("FunctionBlock", 3), ("Function", 6), ("Operator", 6)])
    ReverseIDs = OrderedDict([(3, "FunctionBlock"), (6, "Function"), (6, "Operator")])
    
    
    #@staticmethod
    #def Create():
    #    message_buffer = ctypes.create_string_buffer(FirmwareUpdate_Run_Result.MSG_OFFSET + FirmwareUpdate_Run_Result.SIZE)
    #
    #    Messaging.hdr.SetMessageID(message_buffer, FirmwareUpdate_Run_Result.ID)
    #    Messaging.hdr.SetDataLength(message_buffer, FirmwareUpdate_Run_Result.SIZE)
    #
    #    return message_buffer

    def __init__(self, messageBuffer=None):
        doInit = 0
        if messageBuffer == None:
            doInit = 1
            messageBuffer = ctypes.create_string_buffer(FirmwareUpdate_Run_Result.MSG_OFFSET + FirmwareUpdate_Run_Result.SIZE)
        else:
            try:
                messageBuffer.raw
            except AttributeError:
                newbuf = ctypes.create_string_buffer(len(messageBuffer))
                for i in range(0, len(messageBuffer)):
                    newbuf[i] = bytes(messageBuffer)[i]
                messageBuffer = newbuf
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        self.msg_buffer_wrapper = { "msg_buffer": messageBuffer }

        self.hdr = Messaging.hdr(messageBuffer)
        if doInit:
            self.hdr.SetMessageID(FirmwareUpdate_Run_Result.ID)
            self.hdr.SetDataLength(FirmwareUpdate_Run_Result.SIZE)
            self.initialize()

    def initialize(self):
            pass

    def rawBuffer(self):
        # this is a trick to get us to store a copy of a pointer to a buffer, rather than making a copy of the buffer
        return self.msg_buffer_wrapper["msg_buffer"]

    @staticmethod
    def MsgName():
        return "FirmwareUpdate.Run.Result"
    # Accessors
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def GetResultCode(self):
        """Returns 0x00 if product was successfully able to update to a newer firmware.  Returns 0x01 if the product will apply the update on the next power-up cycle.  Returns 0x02 if the product will apply the update autonomously to all components in a multi-component system when product conditions allow."""
        value = struct.unpack_from('B', self.rawBuffer(), FirmwareUpdate_Run_Result.MSG_OFFSET + 0)[0]
        return value
    
    @msg.units('')
    @msg.default('')
    @msg.minVal('0')
    @msg.maxVal('255')
    @msg.offset('0')
    @msg.size('1')
    @msg.count(1)
    def SetResultCode(self, value):
        """Returns 0x00 if product was successfully able to update to a newer firmware.  Returns 0x01 if the product will apply the update on the next power-up cycle.  Returns 0x02 if the product will apply the update autonomously to all components in a multi-component system when product conditions allow."""
        tmp = min(max(value, 0), 255)
        struct.pack_into('B', self.rawBuffer(), FirmwareUpdate_Run_Result.MSG_OFFSET + 0, tmp)
    

    # Reflection information
    fields = [ \
        FieldInfo(name="ResultCode",type="int",units="",minVal="0",maxVal="255",description="Returns 0x00 if product was successfully able to update to a newer firmware.  Returns 0x01 if the product will apply the update on the next power-up cycle.  Returns 0x02 if the product will apply the update autonomously to all components in a multi-component system when product conditions allow.",get=GetResultCode,set=SetResultCode,count=1, bitfieldInfo = [], enum = [])\
    ]

Messaging.Register("FirmwareUpdate.Run.Result", FirmwareUpdate_Run_Result.ID, FirmwareUpdate_Run_Result)
